### initramfs

La segunda capa del sistema es la encargada de montar el sistema de archivos de
los usuarios y crear un sistema de archivos raiz independiente para cada uno de
ellos. Tambien proporciona un ejecutable ```/init``` PID 1 minimo
([century](https://github.com/piranna/node-century)), cuya labor es únicamente
servir de "red de seguridad" de los procesos que mueran en el sistema para
evitar que provoquen un Kernel Panic, delegando el resto de tareas de un proceso
*init* tipico como por ejemplo el funcionar como demonio del sistema para que la
realicen otros comandos que le proporcione el usuario, o en su defecto en el
ejecutable ubicado en ```/sbin/init``` (ubicación tradicional del script de
arranque en los sistemas UNIX). Este enfoque tambien ha sido tenido en cuenta
[por otras personas](http://ewontfix.com/14/) en especial debido a la polemica
que rodea a [SystemD](http://www.freedesktop.org/wiki/Software/systemd/) y su
diseño centralizando todos los componentes basicos de administracion de los
sistemas Linux mas populares, y a raiz de esto estan surgiendo otros comandos
*init* del sistema minimalistas como [uinit](https://github.com/siblynx/uinit).

#### nodeos-mount-filesystems

El montaje del sistema de archivos de los usuarios es realizado por el modulo
[nodeos-mount-filesystems](https://github.com/piranna/nodeos-mount-filesystems),
el cual es ejecutado en NodeOS por *century* como script de inicio por defecto
al apuntar ```/sbin/init``` a el, y tambien realiza algunas tareas basicas del
arranque del sistema como es el definir el umask del sistema de forma que los
nuevos archivos solo sean accesibles por su creador (*0066*) o la eliminacion de
los modulos, archivos y ejecutables usados durante el arranque del propio
initramfs para ahorrar memoria puesto que ya no seran necesarios.

El primer paso que realiza dicho modulo es montar los sistemas de archivos
virtuales *devtmpfs* y *proc* en los puntos de montaje ```/dev``` y ```/proc```
respectivamente, de forma que se pueda acceder a los parametros con los que se
ha arrancado el kernel de Linux leyendo el contenido del archivo ubicado en
`/proc/cmdline` y acceder al dispositivo que contiene el sistema de archivos
de los usuarios.

Por aumentar la seguridad, el sistema de archivos *devtmpfs* se monta con los
permisos ```0755```, de forma que solo el usuario root pueda acceder a ellos
durante el arranque, dejando al resto de usuarios con un permiso de acceso de
solo-lectura. Mas adelante, se planea crear un gestor de dispositivos al estilo
de ```udev``` con la particularidad de que dara permiso de acceso exclusivo al
usuario que haya abierto el dispositivo de forma que todos los usuarios puedan
acceder directamente al hardware mienras a la vez ninguno pueda interferir en
los dispositivos mientras esten siendo usados por los demas, y ademas estara
diseñado como un sistema de archivos (basado en FUSE) que solo mostrara los
dispositivos a los que el usuario tenga acceso y que no esten sindo usados por
otro usuario en ese momentos. De forma similar, el sistema de archivos *proc* se
monta con la opcion ```hidepid=2``` de manera que un usuario solo tenga acceso a
la información correspondiente a sus propios procesos.

Al ejecutarse el descubrimiento de dispositivos por parte de Linux de forma
asincrona, en algunos casos puede que se ejecute el script de inicio y por tanto
el montaje de la particion de usuarios antes de que esta este disponible, es por
esto por lo que se comprueba la existencia del descriptor de dispositivo durante
5 segundos a intervalos de 1 segundo antes de notificar el error al usuario, y
en tal caso se le solicita que indique su ubicacion explicitamente. En caso de
no haberse indicado una particion con el sistema de archivos de los usuarios
durante el arranque o al solicitarselo explicitamente, se muestra una
advertencia indicando que se usara un disco RAM donde todos los cambios se
perderan al reiniciar el sistema y se ofrece acceso a un interprete REPL.

Una vez que ya se tenga acceso al dispositivo con la particion de los usuarios y
si su montaje ha sido correcto, se eliminan las variables de entorno que solo
son utiles durante el arranque y se define la variable de entorno
`NODE_PATH` para definir la ubicacion de los modulos de Node.js instalados
globalmente a la ruta donde estaran instalados dentro del sistema de archivos
raiz de cada ususario (```/lib/node_modules```). Posteriormente se comprueba si
la particion contiene el directorio de ususario de un usuario administrador, el
cual tendria algunos servicios globales y configuracion del sistema. Este
usuario no es necesario para el funcionamiento correcto del sistema y es
totalmente opcional, aunque en caso de estar disponible se prepara el primero de
todos los usuarios para poder tener acceso a los directorios de todos los demas,
necesario por ejemplo para poder leer la configuracion de los usuarios para el
login distribuido.

Por ultimo, se crea por cada uno de los usuarios un sistema de archivos raiz
propio aislado de el de los demas. Para ello se utiliza OverlayFS usando el
directorio raiz real como capa de solo-lectura y el directorio del usuario como
lectura-escritura, montando ambos directamente en el propio directorio del
usuario. Despues se montan los directorios ```/dev``` y ```/proc``` usando la
opcion ```MS_BIND``` de forma que puedan ser accesibles desde dentro de los
directorios de usuarios, tambien un sistema de archivos *tmpfs* de forma que
cada usuario tenga su propio directorio para archivos temporals. Un caso
especial es el relativo al ususario administrador, el cual al tener acceso a los
directorios de todos los usuarios se mueve el punto de montaje a su ```/tmp```
de forma que posteriormente quede oculto e inacesible por el sistema de archivos
*tmpfs* propio de cada usuario. Una vez hecho esto, se ejecuta el script de
inicio del usuario dentro de una jaula *chroot* creada dentro del punto de
montaje creado por OverlayFS.

#### nodeos-mount

Para el montaje de los sistemas de archivos primero se empleo el modulo
[node-src-mount](https://github.com/groundwater/node-src-mount) usado
originalmente por el proyecto, aunque despues decidi cambiarlo por
[nodeos-mount](https://github.com/NodeOS/nodeos-mount), no solo por tener una
funcionalidad mas completa sino principalmente por su soporte para montar las
particiones asincronamente y de esta forma poder optimizar el arranque del
sistema.

No obstante, este modulo ha requerido ciertas mejoras, como su actualizacion
realizada por [Csaba Szabo](https://github.com/netlovers) (miembro del proyecto)
para poder ser utilizado en Node.js 0.12 usando las macros proporcionadas por el
modulo [nan](https://github.com/nodejs/nan). Por mi parte, las mejoras que
realice yo mismo al modulo son:

* permitir el uso de parametros opcionales en la llamada a las distintas
  funciones del modulo manipulando los argumentos con los que han sido invocadas
* admitir el paso de las opciones de montaje como un array de strings en vez de
  como un conjunto de flags y los parametros del sistema de archivos como un
  objeto literal en vez de como una cadena de texto, de forma que sean mas
  coherente con el estilo empleado en Javascript
* añadir soporte para la deteccion automatica del sistema de archivos de la
  particion si no se ha indicado ninguno probando iterativamente en los sistemas
  de archivos soportados por el kernel y definidos en ```/proc/filesystems``` (e
  ignorando los sistemas de archivos virtuales) de forma similar a como lo
  realiza el comando *mount*
* poder definir el orden en que se probaran los sistemas de archivos, forzando
  por defecto a que se intente usar el formato Ext4 antes que los mas antiguos
  Ext3 o Ext2, igualmente de forma similar a como lo permite el comando *mount*

#### nodeos-mount-utils

Para facilitar el montaje de los sistemas de archivos y el manejo de los puntos
de montaje, tambien he desarrollado el modulo
[nodeos-mount-utils](https://github.com/NodeOS/nodeos-mount-utils). Las
funciones que aporta son:

* *execInit*: ejecuta el script de inicio de un usuario. Para ello por seguridad
  se comprueba que tanto el script como el directorio de usuario tienen el mismo
  UID y GID que seran utilizados para definir el UID y GID del proceso, el cual
  se ejecutara en su propia jaula *chroot* utilizando el propio directirio del
  como sistema de archivos raiz
* *mkdirMount*: monta el sistema de archivos, creando el directorio del punto de
  montaje previamente si no existia. Puesto que no importan los permisos del
  directorio que se utilice como punto de montaje para poder ser usado, este se
  crea con modo *0000* para evitar el que se puedan escribir archivos dentro por
  accidente una vez se haya desmontado el sistema de archivos
* *mountfs*: comprueba si el sistema se esta ejecutando en un entorno Docker (ya
  que no usa montaje de particiones sino apilamiento de containers LXC), y si no
  es el caso, monta el sistema de archivos a partir de nombre de la variable de
  entorno indicada usando la funcion *mkdirMount*. Para comprobar si se esta
  ejecutando en un entorno Docker se comprueba la existencia del archivo
  `.dockerinit` en el directorio raiz
* *mountfs_path*: igual a *mountfs* pero usando directamente la ruta al
  dispositivo en vez de una variable de entorno
* *move*: mueve un sistema de archivos a una nueva ubicacion, y si el directorio
  del anterior punto de montaje esta vacio, lo elimina
* *moveSync*: version sincrona de *move*
* *mkdirMove*: igual a *move*, pero creando previamente el directorio del punto
  de montaje destino si no existe
* *startRepl*: crea un interprete REPL de emergencia y termina el proceso desde
  el que se ha lanzado cuando se sale de este
