### cross-toolchain

Como paso previo a la compilación de los distintos modulos, se ha desarrollado
un modulo encargado de generar un toolchain optimizado para la plataforma para
la que se desea compilar el sistema usado como dependencia por todos los demas
modulos, haciendo el sistema de construcción totalmente autocontenido e
independiente del sistema donde se este construyendo.

El toolchain usa [CLFS Embedded](http://clfs.org/view/clfs-embedded/) como
referencia y esta basado en [gcc](https://gcc.gnu.org/) y [musl](musl-libc.org).
Para configurar la plataforma para la que se generara el toolchain se define la
variable de entorno ```CPU``` con una de las arquitecturas de cpu validas
(actualmente las familias i386, x86_64 y arm) donde por defecto se generara un
toolchain para el microprocesador donde se esta ejecutando. Despues de generarse
el toolchain se hace un checkeo sencillo compilando un pequeño programa para
asegurarse que el cross-compiler funciona correctamente y se eliminan los
simbolos de depuracion de las librerias y ejecutables generados para que ocupen
menos memoria posteriormente en el sistema final.

Siguiendo el proceso indicado por CLFS, la generación del cross-toolchain para
la plataforma deseada se divide en 5 etapas:

1. Generar los headers del kernel.
2. Compilar binutils con soporte para la plataforma.
3. compilar GCC para que pueda generar binarios sin libreria del sistema para la
   plataforma destino. Tambien solo se activa la generacion del compilador de C
   y de librerias estaticas para disminuir el tiempo de compilacion. Tambien se
   desactiva funcionalidad extra que no es necesaria para compilar musl como es
   el soporte multi-hilo y que puede tener problemas de dependencias en el
   momento de hacer la compilacion.
4. Compilar musl usando la version de GCC generada en el paso anterior. Solo se
   genera la version dinamica de la libreria ya que es la unica que se va a
   utilizar despues en el sistema, de esta forma se reduce el tiempo de
   compilacion y la memoria utilizada.
5. Por ultimo se vuelve a compilar GCC, esta vez generando binarios que usen la
   libreria musl generada en el paso anterior como libreria del sistema,
   generando solamente los compiladores de C y C++ (unicos lenguajes necesarios
   para compilar Linux, Node.js y los modulos npm compilados) y el uso de
   librerias dinamicas.

La version de gcc empleada es la 4.7.3 junto con los parches proporcionados por
[CLFS Embedded](http://patches.clfs.org/embedded-dev/gcc-4.7.3-musl-1.patch)
para añadir soporte para musl. Desde el 8 de Mayo de 2015 gcc ofrece
[soporte nativo para dicha libreria](https://www.phoronix.com/scan.php?page=news_item&px=Musl-Libc-GCC-Support),
el cual esta disponible en los snapshots de la rama 6.x y el cual permitiria no
tener que parchearlo. Sin embargo el uso de dichos snapshots resulta en fallos
durante la compilacion de gcc en la libreria ```libsanitizier``` al no encontrar
los simbolos ```dlsym``` y ```RTLD_NEXT```, por lo que de momento no es posible
su actualizacion.

Por otra parte, gcc requiere del uso de las librerias mpfr, gmp y mpc para poder
ser compilado, requiriendo que esten instaladas globalmente. De forma
alternativa es capaz de compilar dichas librerias si estan incluidas dentro de
su propio codigo fuente, para lo que proporciona el script
```contrib/download_prerequisites``` encargado de descargarlas e instalarlas
correctamente. Sin embargo, las versiones que descarga dicho script estan
obsoletas y las nuevas versiones de gcc no pueden compilarse con ellas, por lo
que en su lugar estoy bajando e instalando manualmente las ultimas versiones
disponibles (3.1.2, 6.0.0a y 1.0.2, respectivamente. La ultima version de mpc es
1.0.3, pero no esta disponible en todos los mirrors de la fundacion GNU y puede
dar problemas al intentar descargarla), permitiendo compilarlo sin problemas.

El toolchain tambien proporciona un script en bash encargado de homogeneizar los
valores de las variables de entorno usadas por este o por los modulos que
dependan de el (ubicado en el archivo ```adjustEnvVars.sh```) respecto a la
plataforma, cpu, directorios de archivos temporales, control de errores y demas
variables necesarias durante la compilación de forma que todos ellos puedan
operar en un entorno uniforme y sean mas faciles de modificar y depurar.
