### coreutils.js

Node.js posee un interprete REPL avanzado con soporte de autocompletado e
historico de comandos que lo hacen adecuado como shell interactiva, pero al no
disponer de los comandos basicos de un sistema UNIX hace complejo su uso de
forma habitual. Por ejemplo, para leer el listado del directorio actual es
necesario hacer:

```Javascript
var fs = require('fs')
fs.readdirSync('.')
```

Aunque cumple su funcion, no es adecuado para su uso continuado, haciendo muy
incomodo su uso para casos mas avanzados. Por otro lado, al ser Javascript un
lenguaje de alto nivel se pueden hacer las mismas tareas que con un interprete
*bash* sin necesidad de usar comandos externos al poder ejecutarse facilmente
como funciones, mejorando su rendimiento no solo por no requerir la ejecucion de
un nuevo proceso por cada comando sino por poder hacer uso de caracteristicas
propias de Node.js como es la API de [streams]().

Por otro lado, existen algunas implementaciones de los comandos tipicos de UNIX
en Javascript, siendo la mas popular [shelljs](). Sin embargo, la implementación
de los comandos es incompleta y esta enfocada a solamente replicar la
funcionalidad de dichos comandos como funciones Javascript, lo que dificulta su
integración en otros scripts Javascript teniendo que parsear los datos en cada
etapa y por tanto solo sirve como sustitutivo para evitar el requerir scripts
shell para la ejecucion de comandos sencillos.

[coreutils.js](https://github.com/piranna/coreutils.js) al estar diseñado
especificamente para ser usado dentro de un shell interactivo como *nsh* o el
interprete REPL de Node.js, toma un enfoque distinto creando streams de objetos
para cada uno de los comandos, permitiendo el interconectar los distintos
"comandos" entre si usando la API de streams de Node.js, permitiendo no solo que
dichos streams puedan facilmente integrarse con otros modulos sino que su
rendimiento sea mejor con grandes conjuntos de datos que usando Arrays como
hacen otras librerias. Ademas, al ser streams de objetos, los datos ya estan
atomizados y por tanto no es necesario parsearlos cada vez, solamente acceder a
sus atributos para poder ser procesados. Por ultimo, se añade a cada uno de
estos objetos un metodo [inspect]() de forma que se muestre al imprimirlos por
pantalla un resultado similar al de sus correspondientes comandos UNIX en lugar
de mostrar los objetos en bruto, y tambien se ha añadido a los streams un
atributo *type* indicando el tipo de los objetos dentro del stream para poder
procesarlos mas facilmente de una manera similar a como propone [TermKit]().
