### cross-toolchain

Como paso previo a la compilación de los distintos módulos, se ha desarrollado
un módulo encargado de generar un toolchain optimizado para la plataforma para
la que se desea compilar el sistema usado como dependencia por parte de todos
los demas, haciendo el sistema de construcción totalmente autocontenido e
independiente del sistema donde se este construyendo.

El toolchain usa [CLFS Embedded](http://clfs.org/view/clfs-embedded) como
referencia y esta basado en [gcc](https://gcc.gnu.org) y [musl](musl-libc.org).
Para configurar la plataforma para la que se generara el toolchain se define la
variable de entorno `CPU` con una de las arquitecturas de cpu validas
(actualmente las familias `i386`, `x86_64` y `arm`) donde por defecto se
genera un toolchain para el microprocesador donde se esta ejecutando. Despues de
generarse dicho toolchain se hace un checkeo sencillo compilando un pequeño
programa para asegurarse que el cross-compiler funciona correctamente y se
eliminan los simbolos de depuracion de las librerias y ejecutables generados
para que ocupen menos memoria posteriormente en el sistema final.

Siguiendo el proceso indicado por CLFS, la generación del cross-toolchain para
la plataforma deseada se divide en 5 etapas:

1. Generar los headers del kernel.
2. Compilar `binutils` con soporte para la plataforma deseada.
3. compilar `GCC` para que pueda generar binarios sin libreria del sistema para
   la plataforma destino. Tambien se activa solo la generacion del compilador de
   C y de las librerias estaticas para disminuir el tiempo de compilacion. Por
   último se desactiva funcionalidad extra que no es necesaria para compilar
   `musl` como es el soporte multi-hilo y que pueden dar problemas de
   dependencias en el momento de hacer su compilación.
4. Compilar `musl` usando el binario de `GCC` generado en el paso anterior. Solo
   se genera la versión dinamica de la libreria ya que es la única que se va a
   utilizar despues en el sistema, de esta forma igualmente se reduce el tiempo
   de compilación y el espacio en disco duro utilizado.
5. Por último se vuelve a compilar `GCC`, esta vez generando binarios que usen
   la libreria `musl` del paso anterior como libreria del sistema. Se generan
   solamente los compiladores de C y C++ (únicos lenguajes necesarios para
   compilar Linux, Node.js y los módulos npm compilados) y las versiones
   dinamicas de las librerias de *runtime* (`libgcc_s` y `libstd++`).

La versión de `gcc` empleada es la 4.7.3 junto con los parches proporcionados
por [CLFS Embedded](http://patches.clfs.org/embedded-dev/gcc-4.7.3-musl-1.patch)
para añadir soporte para `musl`. Desde el 8 de Mayo de 2015 `gcc` ofrece soporte
[nativo](https://www.phoronix.com?page=news_item&px=Musl-Libc-GCC-Support) para
dicha libreria, el cual esta disponible para su uso desde la version 5.2.0,
aunque sigue requiriendo su parcheo puesto que el soporte es solo para usar
nativamente `musl` como libreria del sistema, no para que pueda compilarse el
propio `gcc` con ella (esto último no es fundamental para NodeOS, pero ayuda a
que el sistema de generación sea independiente de la plataforma donde se ejecute
al no depender de las librerias instaladas en el sistema). Para ello he decidido
reemplazar dicho parche por los utilizados por el proyecto
[musl-cross](https://github.com/GregorR/musl-cross), cuyo objetivo es facilitar
la creación de cross-compilers basados en `musl`, despues de comprobar que el
correspondiente a *CLFS Embedded* deriva de estos. De este modo, se facilita el
poder utilizar parches de versiones posteriores automaticamente.

El uso de una versión tan antigua de `gcc` esta motivada principalmente puesto
que el uso de dichos parches resulta en fallos durante su compilación debido a
[libsanitizer](https://github.com/gcc-mirror/gcc/tree/master/libsanitizer) al no
encontrar los simbolos `dlsym` y `RTLD_NEXT`. En un principio estudié la
posibilidad de sustituir el proceso de generación del cross-compiler (al menos
parcialmente) por el de *musl-cross* al tener una estructura y un diseño
minimalista similares al empleado en el actual a diferencia de otros generadores
mas completos y genericos como [crosstool-NG](http://crosstool-ng.org). No
obstante, gracias al trabajo de [Kenneth Bentley](https://github.com/heavyk) se
ha visto que es un problema de compatibilidad de la libreria `libsanitizier` con
`musl`, y al ser solo una libreria de apoyo su uso no es estrictamente
[necesario](https://github.com/NodeOS/NodeOS/pull/172#issuecomment-142699830).
De confirmarse esto es probable no haga falta usar un cross-compiler distinto y
solo sea necesario desactivar el uso de la misma, lo cual ademas podria
facilitar el portar NodeOS a otras arquitecturas de microprocesador como por
ejemplo ARM, usada en *Raspberry Pi*.

Por otra parte, `gcc` requiere del uso de las librerias
[mpfr](http://www.mpfr.org), [gmp](https://gmplib.org) y
[mpc](http://mpc.multiprecision.org) para poder ser compilado, requiriendo que
esten instaladas globalmente. De forma alternativa es capaz de compilar dichas
librerias si estan incluidas dentro de su propio código fuente, para lo que se
proporciona el script `contrib/download_prerequisites` encargado de descargarlas
e instalarlas correctamente. Sin embargo, las versiones que descarga dicho
script estan obsoletas y no pueden usarse para compilar las releases mas
recientes de `gcc`, por lo que en su lugar estoy descargando e instalando las
últimas versiones disponibles (3.1.2, 6.0.0a y 1.0.2, respectivamente[^1]) al
mismo tiempo que se descarga el código fuente de `gcc`, permitiendo que éste
pueda compilarse sin problemas.

El toolchain tambien proporciona un script en `bash` encargado de homogeneizar
los valores de las variables de entorno usadas por éste o por los módulos que
dependan de él (ubicado en el archivo `adjustEnvVars.sh`) respecto a la
plataforma, cpu, directorios de archivos temporales, control de errores y otras
variables necesarias durante la compilación de forma que todos ellos puedan
operar en un entorno uniforme y sean mas faciles de modificar y depurar.

El script encargado de descargar las dependencias estaba escrito originariamente
en `bash`, pero debido a que a largo plazo la intención es que NodeOS pueda ser
autocontenido, decidi convertirlo a Javascript y crear el módulo
[download-manager](../../8. apéndices/1. módulos propios/download-manager.html),
de forma que ademas pudiera ser común a todas las capas y pudieran aprovecharse
de las optimizaciónes que en él se hagan en vez de que cada una tuviese el suyo
propio.


[^1]: La última versión de `mpc` es la 1.0.3 pero no esta disponible en todos los mirrors de la fundación GNU y puede dar problemas al intentar descargarla automaticamente.
