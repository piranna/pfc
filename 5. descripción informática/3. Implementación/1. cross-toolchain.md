### cross-toolchain

Como paso previo a la compilación de los distintos módulos, se ha desarrollado
un módulo encargado de generar un toolchain optimizado para la plataforma para
la que se desea compilar el sistema siendo usado como dependencia por parte de
todos los demas, haciendo el sistema de construcción totalmente autocontenido e
independiente del sistema donde se esté construyendo.

El toolchain usa [CLFS Embedded](http://clfs.org/view/clfs-embedded) como
referencia y esta basado en [gcc](https://gcc.gnu.org) y [musl](musl-libc.org).
Para configurar la plataforma para la que se generara el toolchain se define la
variable de entorno `CPU` con una de las arquitecturas de cpu validas
(actualmente las familias `i386` y `x86_64`, en el futuro se espera poder añadir
tambien la familia `arm`) donde por defecto se genera un toolchain para el
microprocesador donde se esta ejecutando. Despues de generarse dicho toolchain
se hace un checkeo sencillo compilando un pequeño programa para asegurarse que
el cross-compiler funciona correctamente, y se eliminan los simbolos de
depuración de las librerias y ejecutables generados para que ocupen menos
memoria posteriormente en el sistema final.

Siguiendo el proceso indicado por *CLFS*, la generación del cross-toolchain para
la plataforma deseada se divide en 5 etapas:

1. Generar los headers del kernel.
2. Compilar `binutils` con soporte para la plataforma deseada.
3. compilar `GCC` para que pueda generar binarios sin libreria del sistema para
   la plataforma destino. Tambien se activa solo la generación del compilador de
   C y de las librerias estáticas para disminuir el tiempo de compilación. Por
   último se desactiva la funcionalidad extra que no sea necesaria para compilar
   `musl` como es el soporte multi-hilo y que pueden dar problemas de
   dependencias posteriormente en el momento de hacer su compilación.
4. Compilar `musl` usando el binario de `GCC` generado en el paso anterior. Solo
   se genera la versión dinámica de la libreria ya que es la única que se va a
   utilizar despues en el sistema, de esta forma igualmente se reduce el tiempo
   de compilación y el espacio en disco duro utilizado.
5. Por último se vuelve a compilar `GCC`, esta vez generando binarios que usen
   la libreria `musl` del paso anterior como libreria del sistema. Se generan
   solamente los compiladores de C y C++ (únicos lenguajes necesarios para
   compilar Linux, Node.js y los módulos npm compilados) y las versiones
   dinamicas de las librerias de *runtime* (`libgcc_s.so` y `libstd++.so`).

#### gcc

La versión de `gcc` empleada es la 5.2.0 junto con los parches proporcionados
por el proyecto [musl-cross](https://github.com/GregorR/musl-cross), cuyo
objetivo es facilitar la creación de cross-compilers basados en `musl`, de los
cuales deriva el proporcionado para la versión 4.7.3 empleada por el proyecto
[CLFS Embedded](http://patches.clfs.org/embedded-dev/gcc-4.7.3-musl-1.patch).
Esto es debido a que aunque desde el 8 de Mayo de 2015 `gcc` ofrece soporte
[nativo](https://www.phoronix.com?page=news_item&px=Musl-Libc-GCC-Support) para
dicha libreria (el cual esta disponible para su uso desde dicha versión 5.2.0),
aún sigue requiriendo su parcheo puesto que dicho soporte sólo es para poder
usar nativamente `musl` como libreria del sistema, no para que pueda compilarse
el propio `gcc` con ella. Esto último no es fundamental para NodeOS, pero ayuda
a que el sistema de generación sea independiente de la plataforma donde se esté
ejecutando al no depender de las librerias instaladas en dicho sistema.

Anteriormente se hacia uso de la versión 4.7.3, tal como viene indicado por las
instrucciones de *CLFS Embedded*. El uso de una versión tan antigua de `gcc`
estaba motivado por el hecho de que al hacer uso los parches del proyecto
*musl-cross* resultaba en fallos durante la compilación de su libreria interna
[libsanitizer](https://github.com/gcc-mirror/gcc/tree/master/libsanitizer), al
no encontrar los simbolos `dlsym` y `RTLD_NEXT`. En un principio se estudió la
posibilidad de sustituir el proceso de generación del cross-compiler (al menos
parcialmente) por el propio de *musl-cross* al tener una estructura y un diseño
minimalista similares al empleado en el actual a diferencia de otros generadores
mas completos y genéricos como [crosstool-NG](http://crosstool-ng.org). No
obstante, gracias al trabajo de [Kenneth Bentley](https://github.com/heavyk) se
ha visto que es un problema de compatibilidad de la libreria `libsanitizier` con
`musl`, y al ser sólo una libreria de apoyo su uso no es estrictamente
[necesario](https://github.com/NodeOS/NodeOS/pull/172#issuecomment-142699830).
Debido a que Ubuntu 15.10 incorpora `gcc` 5.2, el cual usa por defecto desde la
version 5.0 el estandar *C11* en vez de *C89* usado hasta el momento, lo cual
[impide poder compilar](https://gcc.gnu.org/ml/gcc-patches/2015-08/msg00375.html)
versiones anteriores a la 4.8, por lo que se decidió incorporar los cambios
proporcionados por Kenneth Bentley, confirmandose de esta forma que el problema
estaba ocasionado por el uso de `libsanitizier` y por tanto no haciendo falta
usar un cross-compiler distinto. El uso de una versión reciente de `gcc` además
es un requisito indispensable para poder hacer uso de versiones mas modernas de
Node.js (ya que desde la versión 1.0.0 se requiere del uso de un compilador con
soporte de *C++14*, como es el caso de `gcc` 4.8), y además podría facilitar el
portar NodeOS a otras arquitecturas de microprocesador como por ejemplo ARM,
usada en el microordenador *Raspberry Pi*.

Por otra parte, `gcc` requiere del uso de las librerias
[mpfr](http://www.mpfr.org), [gmp](https://gmplib.org) y
[mpc](http://mpc.multiprecision.org) para poder ser compilado, requiriendo que
estén instaladas globalmente. De forma alternativa, es capaz de compilar dichas
librerias si estan incluidas dentro de su propio código fuente, para lo que se
proporciona el script `contrib/download_prerequisites` encargado de descargarlas
e instalarlas correctamente. Sin embargo, las versiones que descarga dicho
script estan obsoletas y no pueden usarse para compilar las releases mas
recientes de `gcc`, por lo que en su lugar estoy descargando e instalando las
últimas versiones disponibles (3.1.2, 6.0.0a y 1.0.2, respectivamente[^1]) al
mismo tiempo que se descarga el código fuente de `gcc`, permitiendo que éste
pueda compilarse sin problemas.

#### Descarga de dependencias

El toolchain tambien proporciona un script en `bash` encargado de homogeneizar
los valores de las variables de entorno usadas por éste o por los módulos que
dependan de él (ubicado en el archivo `adjustEnvVars.sh`) respecto a la
plataforma, cpu, directorios de archivos temporales, control de errores y otras
variables necesarias durante la compilación de forma que todos ellos puedan
operar en un entorno uniforme y sean mas faciles de modificar y depurar.

El script encargado de descargar las dependencias estaba escrito originariamente
en `bash`, pero debido a que a largo plazo la intención es que NodeOS pueda ser
autocontenido, decidi convertirlo a Javascript y crear el módulo
[download-manager](../../8. apéndices/1. módulos propios/download-manager.html),
de forma que ademas pudiera ser común a todas las capas y pudieran aprovecharse
de las optimizaciónes que en él se hagan en vez de que cada una tuviese su
propio script para administrar la descarga de sus dependencias.


[^1]: La última versión de `mpc` es la 1.0.3 pero no esta disponible en todos los mirrors de la fundación GNU, lo cual puede dar problemas al intentar descargarla automaticamente si se emplea un mirror que no la contenga, por lo que en su lugar se ha decidio usar la versión 1.0.2 que si esta disponible en todos ellos.
