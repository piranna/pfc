### barebones

La primera capa del sistema consiste solamente en un kernel Linux que ejecuta un
interprete REPL de Node.js, siendo ésta la versión mas mínima del sistema.

El ejecutable de Node.js es compilado desactivando las opciones de depuración
para reducir su tamaño ya que estará permanentemente alojado en memoria, y
también la cache de módulos ya que al usar un cross-compiler es probable que se
este haciendo una compilación para una plataforma distinta a la actual y por lo
tanto la cache seria invalida, por lo que de esta forma aceleramos el tiempo de
compilación al ahorrarnos este paso. Igualmente tampoco se instala el gestor de
paquetes `npm` por defecto, dejando que sea el propio usuario el que lo instale
mas adelante en su directorio si lo desea.

El proceso de generación de la capa de barebones también se encarga de
descargar y compilar el código fuente de la máquina virtual QEmu para poder
ejecutar las pruebas del sistema y poder ejecutarlo posteriormente en local.
Esto además permite el hacer el proceso de generación transparente a la versión
de QEmu instalada en el sistema, ya que por ejemplo la versión que ofrece
Ubuntu 14.04 por defecto es demasiado antigua y no incluye funcionalidad
necesaria para poder ejecutar NodeOS. Se hace uso de un fork del mismo
[desarrollado por Microsoft](https://github.com/0xabu/qemu) en vez del código
fuente principal debido a que dicho fork incorpora soporte nativo para emular
las placas *Rapsberry Pi* y mas especialmente *Raspberry Pi 2*, pero sobretodo
debido a que las versiones mas recientes del kernel de Linux hacen uso de la
instrucción `SETEND` al compilarse para ARM, la cual no esta incorporada dentro
de las versiones estándar de QEmu.

#### Node.js

La versión de Node.js utilizada es la v0.11.14, la cual se ha parcheado para que
la versión de la librería [OpenSSL](https://www.openssl.org) que incluye pueda
compilarse usando `musl` en vez de `glibc`[^1]. El uso de esta versión se debe a
que en versiones posteriores se han introducido cambios que impiden que Node.js
[pueda usarse como `PID 1`](https://github.com/nodejs/node/issues/3204) al
entrar en un bucle y consumir toda la CPU, haciendo que no se puedan usar en
NodeOS. No obstante, el problema esta identificado en un cambio de versión del
[motor de Javascript v8](https://github.com/joyent/node/pull/9185) (del cual ya
habían sido reportados problemas por parte de varias personas), y se espera que
próximamente esto pueda arreglarse y usarse una versión de Node.js mas reciente,
la cual además no necesitaría ser parcheada para funcionar correctamente con
`musl`. Por último, también se ha incluido en su código fuente dentro del módulo
[os](https://nodejs.org/api/os.html) la versión de NodeOS para la que se esta
compilando como una cadena de texto, de forma que ésta pueda conocerse
posteriormente en tiempo de ejecución.

Para descubrir que el error que no permitía usar Node.js como `PID 1` estaba
ocasionado por `v8` se ha hecho uso de `git bisect`. No obstante, para descubrir
el commit exacto esto no era posible ya que Node.js hace uso de una versión
parcheada del mismo. El método que se ha empleado ha consistido primero en
identificar los cambios hechos por Node.js sobre la versión 3.28.73 de v8 (la
versión incluida en Node.js en el momento en que se introdujo el fallo) y
aplicarlos como un `commit` independiente dentro del código de `v8` sin
modificar, para a continuación aplicarlos iterativamente mediante `cherry-pick`
desde cada una de las versiones que han compilado de forma satisfactoria en cada
una de sus versiones anteriores hasta la versión 3.26.33 (versión incluida en
Node.js justo antes de introducirse el fallo), aplicando los cambios que fuesen
necesarios (principalmente ir eliminando las modificaciones introducidas por los
parches realizados por el equipo de Node.js). De este modo, los cambios que se
hubieran introducido podrían adaptarse mejor a las posibles modificaciones que
se hubiesen introducido en el código, haciendo mas fácil su adaptación.
Finalmente, se compilaba Node.js con la nueva versión modificada de `v8` y se
comprueba si los tests de NodeOS pasan correctamente. Para esto mismo se ha
hecho mas flexible el mecanismo de tests de NodeOS, permitiendo que se pueda
habilitar un REPL interactivo directamente sobre el binario de Node.js recién
compilado mediante el uso de *QEmu user mode* para comprobar que la versión de
`v8` utilizada es la correcta. Sin embargo, al llegar a la versión 3.26.33 se
ha comprobado que ésta seguía sufriendo del mismo problema. Se ha intentado
hacer el mismo proceso a la inversa (empezar a aplicar los parches desde la
versión 3.26.33 en adelante) obteniendo fallos en ejecución (*violación de
segmento*) o errores de compilación para versiones posteriores a la 3.27.0, por
lo que se han interrumpido dichas pruebas. Se esperaba que al actualizar el
*cross-compiler* para hacer uso de `gcc` 5.2 dicho problema quedaría resuelto
en las últimas versiones de Node.js, pero al no ser así la solución parece ser
el uso de un [comando `init`](https://github.com/NodeOS/NodeOS/issues/190)
mínimo como ha propuesto [Christine Dodrill](https://github.com/Xe) de forma
que pueda ejecutarse y depurarse de forma independiente. Esto tendría la
ventaja adicional de disminuir el consumo de memoria al no requerir el usarse
una instancia de v8 que de otra forma estaría inutilizada, aunque se esta a la
espera de poder hacer pruebas al respecto para comprobar si es una solución
válida.

Por otro lado, en un principio quise que el binario de Node.js estuviese
compilado estáticamente, no solo para simplificar el sistema de archivos de los
usuarios al eliminar el uso de librerías dinámicas globales (alojadas en el
directorio `/lib`) sino ante la falsa creencia de que el comando `init` del
sistema debía estar compilado de esta manera. Es por esto por lo que añadí una
[opción de configuración a Node.js](https://github.com/joyent/node/pull/8274)
para que pudiese ser compilado estáticamente, aunque finalmente no esta siendo
usada puesto que al incluirse `musl` en un ejecutable puramente estático se
pierde la capacidad de cargar posteriormente librerías dinámicas (`.so`),
necesario para poder cargar los módulos externos compilados. No obstante, se
pueden seguir usando normalmente los módulos escritos en Javascript, por lo que
esta funcionalidad puede seguir siendo práctica por ejemplo en sistemas
embebidos si dichos módulos compilados se incluyen dentro del propio binario de
Node.js.

#### Linux

La versión de Linux utilizada es la 4.3.2, aunque es válida cualquiera superior
a la 4.1 ya que se hace uso del soporte de múltiples capas de sólo lectura en el
sistema de archivos
[OverlayFS](https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt),
el cual se incluyó en su código fuente en la versión 3.20-rc1 (después
renombrada a 4.0-rc1) y que es usado como base para la creación de los sistemas
de archivos raíz independientes para cada uno de los usuarios.

La configuración del kernel se basa en la configuración por defecto para cada
plataforma, a la que después se le deshabilita el soporte de módulos (de forma
que todo el kernel quede compilado en un único binario, simplificando después la
administración del sistema) y también las herramientas de depuración y algunos
componentes obsoletos o superfluos activados por defecto como son algunos
sistemas de archivos no habituales hoy día como *minixfs* para reducir el tamaño
del kernel.

En la configuración del kernel también se ha habilitado el soporte para `FUSE` y
*OverlayFS* antes citado, al igual que el soporte para `initramfs` de forma que
se pueda incluir el ejecutable de Node.js y sus librerías asociadas dentro del
propio binario del kernel. Para poder crear el `initramfs` sin requerir permisos
de administrador (necesarios para configurar el usuario y los permisos de acceso
de los archivos incluidos) se ha decidido optar por la opción de usar un archivo
de configuración. Sin embargo, al no poder usarse rutas fijas a los archivos a
incluir ya que estas dependen de la plataforma y CPU para el que se esta
compilando el sistema, se ha decidido incluir dichos valores como variables de
shell dentro de dicho archivo de configuración, procesándolo previamente a su
uso mediante el comando `echo` para que funcione como un sistema de plantillas
rudimentario, y generando el archivo de configuración que se va a usar
finalmente con sus rutas correctas:

```bash
eval "echo \"$(< cpio.txt)\"" > $OBJ_DIR/cpio.txt
```

Tanto *Docker* como *vagga* utilizan su propio kernel de Linux (en concreto, el
que se este usando en el sistema huésped), por lo que sólo es necesario generar
la capa base del sistema. Para poder usar el mismo archivo de configuración que
el usado para incluir el ejecutable de Node.js y sus librerías dentro del kernel
de Linux, primero se genera la utilidad `gen_init_cpio` usada internamente por
el proceso de compilación del kernel de Linux y la cual puede crear una imagen
de *initram* en formato `cpio`, y después se convierte dicho archivo al formato
`tar` requerido por *Docker* y *vagga* para inicializar el sistema de archivos
raíz del contenedor LXC.

#### Comprobaciones finales

Por último, se comprueba que la capa *barebones* de NodeOS funciona correctamente.
Para ello, se ejecuta dentro de una máquina virtual QEmu redireccionando la
entrada y salida estándar de forma que pueda ser procesada, y mediante el módulo
[suppose](../../8. apéndices/2. colaboraciones con proyectos externos/node-suppose.html)
(el cual en un sistema interactivo devuelve una respuesta ante la recepción de
un determinado texto, y al que añadí soporte de ejecución de funciones como
respuesta) se espera a recibir el prompt REPL de Node.js corriendo dentro de
NodeOS en un tiempo prudencial (actualmente 30 segundos) antes de emitir un
fallo, y después se le envían fragmentos de código Javascript para comprobar que
los procesa y responde correctamente a ellos.

#### Problemas encontrados

Uno de los problemas con los que me he encontrado ha sido el poder testear el
funcionamiento del binario de Node.js de forma aislada una vez generado al estar
compilado usando `musl` como librería del sistema en lugar de `glibc` usada en
Ubuntu por defecto, por lo que es necesario usar su propio cargador de librerías
dinámicas invocando directamente a `libc.so`. Sin embargo, al hacerlo de esta
manera me encontré con que el binario de Node.js no procesaba los datos que se
enviaban por la entrada estándar. En un principio llegué a la conclusión de que
al usar directamente `libc.so` este genera un nuevo proceso hijo para ejecutar
el programa propiamente dicho haciendo un duplicado de los descriptores de
fichero de la entrada y salida estándar, por lo que no es posible testearlo de
forma automática del mismo modo que se hace con la capa de *barebones* entera
mediante el uso de *suppose* ya que este hace uso de un pipe con el proceso hijo
a testear, el cual en este caso seria `libc.so` y no el binario de Node.js. Por
este motivo me planteé como alternativas el uso de `chroot` al estilo de como
funciona [vagga](https://github.com/tailhook/vagga) o incluso de hacer uso de
[QEmu User Mode](http://qemu.weilnetz.de/qemu-doc.html#QEMU-User-space-emulator),
pero en el primer caso el comando `chroot` requiere de permisos de administrador
y en el segundo sigue siendo necesario especificar el cargador dinámico a usar
(o hacer un link simbólico en la raíz del sistema), por lo que ambas soluciones
quedan igualmente descartadas.

La solución paso finalmente por hacer uso del parámetro `--interactive` de
Node.js, el cual fuerza a iniciar un interprete REPL incluso en el caso de que
crea que la entrada estándar no corresponde a un terminal (probablemente
derivado del hecho de ser ejecutado indirectamente por `libc.so`), con lo que de
este modo sí pudo usarse *suppose* para comprobar que funcionaba perfectamente.
Además, el test hace uso de *QEmu User Mode* de forma que también puedan
comprobarse binarios compilados para otras arquitecturas de CPU.


[^1]: En versiones posteriores a la 0.12.1 esto ya no es necesario al incluir la versión 1.0.1m de OpenSSL en la cual ya está incluido dicho soporte. Este bug estaba siendo ignorado desde hace [mas de 3 años](https://rt.openssl.org/Ticket/Display.html?id=2823&user=guest&pass=guest) y parcheado varias veces de [forma externa](https://github.com/maximeh/buildroot/blob/master/package/openssl/openssl-004-musl-termios.patch), y el cual finalmente fue aceptado debido a mi [insistencia](https://github.com/openssl/openssl/issues/163) al respecto.
