### barebones

La primera capa del sistema consiste solamente en un kernel Linux que ejecuta un
interprete REPL de Node.js, siendo ésta la versión mas mínima del sistema.

El ejecutable de Node.js es compilado desactivando las opciones de depuración
para reducir su tamaño ya que estara permanentemente alojado en memoria, y
también la cache de módulos ya que al usar un cross-compiler es probable que se
este haciendo una compilación para una plataforma distinta a la actual y por lo
tanto la cache seria invalida, por lo que de esta forma aceleramos el tiempo de
compilación al ahorrarnos este paso. Igualmente tampoco se instala el gestor de
paquetes `npm` por defecto, dejando que sea el própio usuario el que lo instale
mas adelante en su directorio si lo desea.

El proceso de generación de la capa de barebones tambien se encarga de
descargar y compilar el código fuente de la máquina virtual QEmu para poder
ejecutar las pruebas del sistema y poder ejecutarlo posteriormente en local.
Esto además permite el hacer el proceso de generación transparente a la versión
de QEmu instalada en el sistema, ya que por ejemplo la versión que ofrece
Ubuntu 14.04 por defecto es demasiado antigua y no incluye funcionalidad
necesaria para poder ejecutar NodeOS. Se hace uso de un fork del mismo
[desarrollado por Microsoft](https://github.com/0xabu/qemu) en vez del código
fuente principal debido a que dicho fork incorpora soporte nativo para emular
las placas *Rapsberry Pi* y mas especialmente *Raspberry Pi 2*, pero sobretodo
debido a que las versiones mas recientes del kernel de Linux hacen uso de la
instrucción `SETEND` al compilarse para ARM, la cual no esta incorporada dentro
de las versiones estandar de QEmu.

#### Node.js

La versión de Node.js utilizada es la v0.11.14, la cual se ha parcheado para que
la versión de la libreria [OpenSSL](https://www.openssl.org) que incluye pueda
compilarse usando `musl` en vez de `glibc`. El uso de esta versión es debido a
que en versiones posteriores se han introducido cámbios que impiden que Node.js
[pueda usarse como `PID 1`](https://github.com/nodejs/node/issues/3204) al
entrar en un bucle y consumir toda la CPU, haciendo que no se puedan usar en
NodeOS. No obstante, el problema esta identificado en un cámbio de versión del
motor de Javascript v8 (del cual ya habian sido reportados problemas por parte
de varias personas), y se espera que proximamente esto pueda arreglarse y usarse
una versión de Node.js mas reciente, la cual además no necesitaréa ser parcheada
para funcionar correctamente con `musl`. Por último, tambien se le ha incluido
dentro de su código fuente en el módulo [os](https://nodejs.org/api/os.html) la
versión de NodeOS para la que se esta compilando como una cadena de texto, de
forma que esta pueda conocerse posteriormente en tiempo de ejecución.

Para descubrir que el error que no permitia usar Node.js como `PID 1` estaba
ocasionado por `v8` se ha hecho uso de `git bisect`. No obstante, para descubrir
el commit exacto esto no era posible ya que Node.js hace uso de una versión
parcheada del mismo. El método que se ha empleado ha consistido primero en
identificar los cámbios hechos por Node.js sobre la version 3.28.73 de v8 (la
versión incluida en Node.js en el momento en que se introdujo el fallo) y
aplicarlos como un `commit` independiente dentro del código de `v8` sin
modificar, para a continuación aplicarlos iterativamente mediante `cherry-pick`
desde cada una de las versiones que han compilado de forma satisfactoria en cada
una de sus versiones anteriores hasta la versión 3.26.33 (versión incluida en
Node.js justo antes de introducirse el fallo), aplicando los cambios que fuesen
necesariós (principalmente ir eliminando las modificaciones introducidas por los
parches realizados por el equipo de Node.js). De este modo, los cambios que se
hubieran introducido podrian adaptarse mejor a las posibles modificaciones que
se hubiesen introducido en el código, haciendo mas fácil su adaptación.
Finalmente, se compilaba Node.js con la nueva versión modificada de `v8` y se
comprueba si los tests de NodeOS pasan correctamente. Para esto mismo se ha
hecho mas flexible el mecanismo de tests, permitiendo que se pueda habilitar un
REPL interactivo directamente sobre el binario de Node.js recién compilado
mediante el uso de *QEmu user mode* para comprobar que la versión de `v8`
utilizada es la correcta. Sin embargo, al llegar a la versión 3.26.33 se ha
comprobado que esta seguia sufriendo del mismo problema. Se ha intentado hacer
el mismo proceso a la inversa (empezar a aplicar los parches desde la versión
3.26.33 en adelante) obteniendo fallos en ejecución (*violación de segmento*) o
errores de compilación para versiones posteriores a la 3.27.0, por lo que se han
interrumpido las pruebas a la espera de actualizar el *cross-compiler* para que
haga uso de `gcc` 5.2 con la esperanza de que el problema haya sido resuelto en
las últimas versiones de Node.js.

#### Linux

La version de Linux utilizada es la 4.3.2, aunque es válida cualquiera superior
a la 4.1 ya que se hace uso del soporte de multiples capas de sólo lectura en el
sistema de archivos
[OverlayFS](https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt),
el cual se incluyó en su código fuente en la versión 3.20-rc1 (después
renombrada a 4.0-rc1) y que es usado como base para la creación de los sistemas
de archivos raiz independientes para cada uno de los usuarios.

La configuración del kernel se basa en la configuración por defecto para cada
plataforma, a la que después se le deshabilita el soporte de módulos (de forma
que todo el kernel quede compilado en un único binario, simplificando despues la
administración del sistema) y tambien las herramientas de depuración y algunos
componentes obsoletos o superfluos activados por defecto como son algunos
sistemas de archivos no habituales hoy dia como *minixfs* para reducir el tamaño
del kernel.

En la configuración del kernel también se ha habilitado el soporte para `FUSE` y
*OverlayFS* antes citado, al igual que el soporte para `initramfs` de forma que
se pueda incluir el ejecutable de Node.js y sus librerias asociadas dentro del
propio binario del kernel. Para poder crear el `initramfs` sin requerir permisos
de administrador (necesarios para configurar el usuario y los permisos de acceso
de los archivos incluidos) se ha decidido optar por la opción de usar un archivo
de configuración. Sin embargo, al no poder usarse rutas fijas a los archivos a
incluir ya que estas dependen de la plataforma y CPU para el que se esta
compilando el sistema, se ha decidido incluir dichos valores como variables de
shell dentro de dicho archivo de configuración, procesandolo previamente a su
uso mediante el comando `echo` para que funcione como un sistema de plantillas
rudimentario, y generando el archivo de configuración que se va a usar
finalmente con sus rutas correctas:

```bash
eval "echo \"$(< cpio.txt)\"" > $OBJ_DIR/cpio.txt
```

Tando *Docker* como *vagga* utilizan su propio kernel de Linux (en concreto, el
que se este usando en el sistema huesped), por lo que sólo es necesario generar
la capa base del sistema. Para poder usar el mismo archivo de configuración que
el usado para incluir el ejecutable de Node.js y sus librerias dentro del kernel
de Linux, primero se genera la utilidad `gen_init_cpio` usada internamente por
el proceso de compilación del kernel de Linux y la cual puede crear una imagen
de initram en formato `cpio`, y despues se convierte dicho archivo al formato
`tar` requerido por *Docker* y *vagga* para inicializar el sistema de archivos
raiz del contenedor LXC.

#### Comprobaciónes finales

Por último, se comprueba que la capa *barebones* de NodeOS funciona correctamente.
Para ello, se ejecuta dentro de una máquina virtual QEmu redireccionando la
entrada y salida estandar de forma que pueda ser procesada, y mediante el módulo
[suppose](../../8. apéndices/2. colaboraciones con proyectos externos/node-suppose.html)
(el cual en un sistema interactivo devuelve una respuesta ante la recepción de
un determinado texto, y al que añadi soporte de ejecución de funciones como
respuesta) se espera a recibir el prompt REPL de Node.js corriendo dentro de
NodeOS en un tiempo prudencial (actualmente 30 segundos) antes de emitir un
fallo, y después se le envian fragmentos de código Javascript para comprobar que
los procesa y responde correctamente a ellos.

#### Problemas encontrados

Uno de los problemas con los que me he encontrado ha sido el poder testear el
funcionamiento del binario de Node.js de forma aislada una vez generado al estar
compilado usando `musl` como libreria del sistema en lugar de `glibc` usada en
Ubuntu por defecto, por lo que es necesario usar su propio cargador de librerias
dinámicas invocando directamente a `libc.so`. Sin embargo, al hacerlo de esta
manera me encontré con que el binario de Node.js no procesaba los datos que se
enviaban por la entrada estandar. En un principio llegué a la conclusión de que
al usar directamente `libc.so` este genera un nuevo proceso hijo para ejecutar
el programa propiamente dicho haciendo un duplicado de los descriptores de
fichero de la entrada y salida estandar, por lo que no es posible testearlo de
forma automática del mismo modo que se hace con la capa de *barebones* entera
mediante el uso de *suppose* ya que este hace uso de un pipe con el proceso hijo
a testear, el cual en este caso seria `libc.so` y no el binario de Node.js. Por
este motivo me planteé como alternativas el uso de `chroot` al estilo de como
funciona [vagga](https://github.com/tailhook/vagga) o incluso de hacer uso de
[QEmu User Mode](http://qemu.weilnetz.de/qemu-doc.html#QEMU-User-space-emulator),
pero en el primer caso el comando `chroot` requiere de permisos de administrador
y en el segundo sigue siendo necesario especificar el cargador dinamico a usar
(o hacer un link simbolico en la raiz del sistema), por lo que ambas soluciones
quedan igualmente descartadas.

La solución paso finalmente por hacer uso del parametro `--interactive` de
Node.js, el cual fuerza a iniciar un interprete REPL incluso en el caso de que
crea que la entrada estandar no corresponde a un terminal (probablemente
derivado del hecho de ser ejecutado indirectamente por `libc.so`), con lo que de
este modo sí pudo usarse *suppose* para comprobar que funcionaba perfectamente.
Ademas, el test hace uso de *QEmu User Mode* de forma que también puedan
comprobarse binarios compilados para otras arquitecturas de CPU.
