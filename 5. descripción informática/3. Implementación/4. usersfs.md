### usersfs

La ultima capa del sistema corresponde a la generacion de la particion de los
usuarios. No tiene una repercusion directa en el funcionamiento del sistema,
sino que su funcionalidad es principalmente para hospedar un usuario de ejemplo
y mostrar como se crearia una particion de usuarios real para un entorno de
produccion. Por tal motivo solo contiene los usuarios *root* y *nodeos*, estando
pendiente de definir un metodo para generar una particion de usuarios para
produccion.

El metodo para generar ambos usuarios es el mismo, consistente en la creacion de
su directorio de usuario y despues la instalacion de los paquetes definidos en
un archivo de texto usando npm. La instalacion se hace globalmente dentro del
propio directorio y configurada de tal forma que use el cross-toolchain antes
generado, y despues se hace un link simbolico al ejecutable que debe actuar como
*init* de dicho usuario.

Para generar la imagen de particion se emplea el comando *genext2fs*, indicando
que se genere el sistema de archivos Ext2 con un tamaño de bloque de 1024 bytes
y un ratio de 4KB por inodo (por defecto *genext2fs* genera el menor numero de
inodos necesario para hospedar el sistema de archivos a crear, lo cual solo es
util mayormente en sistemas de solo-lectura para reducir su tamaño), siendo
estos los valores usados por defecto en entornos de escritorio habitualmente y
que ofrecen una buena relaccion de espacio consumido para metadatos respecto a
los propios datos en condiciones normales. Despues se activa manualmente en
dicho sistema de archivos el soporte para journaling para aumentar la integridad
de los datos mediante el comando `/sbin/tune2fs -j`.

Para aumentar la seguridad del sistema operativo, el sistema de archivos de los
usuarios se crea con la opcion *squash* la cual asigna a todos los archivos el
UID y GID `0` (generalmente asociados al usuario administrador) y sus permisos
de forma que solo puedan ser accedidos por el propietario de estos. Puesto que
el UID y GID del directorio de usuario son usados para identificar al usuario y
posteriormente definir los permisos de la jaula *chroot* donde se ejecutara este,
despues se utiliza un script que hace uso de la utilidad *debugfs* para poder
cambiar el UID y GID de los archivos correspondientes al usuario *nodeos* sin
necesitar permisos de administrador al poder hacerlo directamente sobre la
imagen de particion.

#### root

El usuario *root* es el encargado de gestionar el arranque del sistema y los
servicios globales de este, y por tanto tambien es el unico con permisos de
administrador. Actualmente, su unica funcionalidad es inicializar un
pseudo-terminal donde el usuario de demo *nodeos* pueda acceder al sistema y
mantenerlo activo cuando este termine su sesion.

A diferencia de otros sistemas operativos, este usuario no es necesario para su
funcionamiento ya que su unica tarea es inicializar elementos del sistema que
son comunes a todos los usuarios o que requieren acceder a la informacion
contenida en los directorios de cada uno de ellos, como es el caso de `logon`
para poder leer las contraseñas y la configuracion de sesion de cada uno de
ellos. En caso de que estos no existan o no sean necesarios, se puede eliminar
el directorio de *root* de la particion de usuarios y a partir de entonces no
habria en el sistema ningun proceso en ejecucion con permisos de administrador
excepto el proceso PID 1 (*century*).

##### forever starter

[forever](https://github.com/foreverjs/forever) es uno de los mas populares
gestores de tareas de Node.js junto con [PM2](http://pm2.keymetrics.io), y se
decidio usarlo en un diseño anterior de NodeOS a modo de demonio del sistema
debido a su capacidad de administrar y reiniciar procesos de varios usuarios.
Para esta tarea le añadi la capacidad de poder usar un archivo de configuracion
durante su arranque aparte de poder ejecutar funciones y no solo comandos
externos. Sin embargo, debido al diseño actual donde cada usuario tiene su
propio sistema de archivos raiz y su propio ejecutable de inicio (pudiendo este
ser tambien un gestor de tareas) se esta estudiando el sustituirlo por alguna
alternativa mas simple que requiera menos recursos y sea mas facil de mantener.

##### node-bin-getty

El pseudo-terminal ```/dev/console``` es inicializado por el modulo
[node-bin-getty](https://github.com/netlovers/node-bin-getty) y despues lo usa
como entrada y salidas estandar del proceso que se le pase como argumento para
que actue como login del sistema. Este modulo necesitó que corregiese un pequeño
bug para evitar que se cerraran dichas entrada y salidas estandar antes de que
el proceso se iniciara, al igual que la actualizacion de sus dependencias
[node-src-unistd](https://github.com/netlovers/node-src-unistd) y
[node-src-termios](https://github.com/netlovers/node-src-termios) para poder
funcionar en Node.js 0.11.

##### logon

El acceso al sistema es ofrecido por [logon](https://github.com/piranna/logon),
el cual no tiene una base de datos centralizada de los usuarios sino que la
informacion de estos esta almacenada dentro del directorio de cada uno de ellos.
Lo diseñe de esta manera para que ls) se esta estudiando el sustituirlo por
alguna alternativa mas simple que requiera menos recursos y sea mas facil de
mantener

##### node-bin-getty

El pseudo-terminal ```/dev/console``` es inicializado por el modulo
[node-bin-getty](https://github.com/netlovers/node-bin-getty) y despues lo usa
como entrada y salidas estandar del proceso que se le pase como argumento para
que actue como login del sistema. Este modulo necesitó que corregiese un pequeño
bug para evitar que se cerraran dichas entrada y salidas estandar antes de que
el proceso se iniciara, al igual quos usuarios pudieran cambiar su informacion
de acceso (contraseña, shell por defecto...) sin requerir permisos de
administrador ni que se dependiera de un usuario administrador para poder
cambiarlos. Esto tiene el inconveniente de que en caso de que el usuario se
infectara con un virus o sufriera un hackeo no solo se comprometeria toda su
informacion sino tambien el acceso a su cuenta ya que estos podrian haber
cambiado la contraseña, pero por otra parte al no haber una base de datos de
usuarios centralizada ni un usuario administrador ni archivos o elementos
comunes a todos los usuarios, solo se comprometeria la cuenta a la que se
hubiera tenido acceso en vez de todo el sistema.

#### nodeos

La funcionalidad del usuario *nodeos* es solamente servir de ejemplo de como
seria un usuario del sistema, aunque tambien incluye algunos comandos basicos y
utilidades de rendimiento para pruebas.

Entre los modulos que se instalan en este usuario de ejemplo estan:

* **basicos**: el gestor de paquetes npm, una version mejorada de la shell nsh y
  bin-man para poder leer los archivos `README.md` de los modulos como se haria
  con las paginas de manual en un sistema UNIX.
* **red**: ip e ifconfig para configurar la tarjeta de red y las rutas de red, y
  ntp-client y dhcpjs para diversas pruebas
* **editores**: slap, se piensa añadir tambien hipster
* **benchmarks**: performance y loadtest

Aparte, tambien se descargan e instalan desde sus repositorios los modulos
*blessed-contrib* y
[node-canvas](../../../8. apéndices/2. módulos/3. node-canvas.md) con objeto de
ser usado para pruebas y demos de graficos ASCII y en framebuffer,
respectivamente.

Por ultimo, se copian en el directorio `/etc` dentro del propio directorio del
usuario los archivos `logon.json` que sera leido por *logon* para permitir el
acceso al sistema, y `resolv.conf` para que funcione correctamente la resolución
de nombres usando por defecto los servidores DNS de Google y pudiendo ser
cambiados por el usuario afectando solamente a sus propias aplicaciones.
