### usersfs

La ultima capa del sistema corresponde a la generación de la partición de los
usuarios. No tiene una repercusion directa en el funcionamiento del sistema,
sino que su funcionalidad es principalmente para hospedar un usuario de ejemplo
y mostrar como se crearia una particion de usuarios real para un entorno de
produccion. Por tal motivo solo contiene los usuarios *root* y *nodeos*, estando
pendiente de definir un metodo independiente para generar una partición de
usuarios lista para produccion.

El metodo para generar ambos usuarios es el mismo, consistente en la creacion de
su directorio de usuario y despues la instalacion de los paquetes definidos en
un archivo de texto usando npm. La instalacion se hace globalmente dentro del
propio directorio y configurada de tal forma que use el
[cross-toolchain](0. cross-toolchain.html) antes generado, y despues se hace un
link simbolico al ejecutable que debe actuar como *init* de dicho usuario.

Para generar la imagen de particion se hace uso del comando
[genext2fs](http://genext2fs.sourceforge.net), indicando que se genere el
sistema de archivos `Ext2` con un tamaño de bloque de 1024 bytes y un ratio de
4KB por inodo (por defecto *genext2fs* genera el menor número de inodos
necesario para hospedar el sistema de archivos a crear, lo cual solo es útil
mayormente en sistemas de solo-lectura para reducir su tamaño), siendo estos los
valores usados por defecto en entornos de escritorio habitualmente y que ofrecen
una buena relaccion de espacio consumido para metadatos respecto a los propios
datos en condiciones normales. Despues se activa manualmente en dicho sistema de
archivos el soporte para journaling para mejorar la integridad de los datos
mediante la ejecución del comando `/sbin/tune2fs -j`.

Para aumentar la seguridad del sistema operativo, el sistema de archivos de los
usuarios se crea con la opcion *squash* la cual asigna a todos los archivos el
UID y GID `0` (generalmente asociados al usuario administrador) y sus permisos
de forma que solo puedan ser accedidos por el propietario de estos. Puesto que
el UID y GID del directorio de usuario son usados para identificar al usuario y
posteriormente definir los permisos de la jaula *chroot* donde se ejecutara este,
despues se utiliza un script que hace uso de la utilidad
[debugfs](http://linux.die.net/man/8/debugfs) para poder cambiar el UID y GID de
los archivos correspondientes al usuario *nodeos* sin necesitar permisos de
administrador al poder hacerlo directamente sobre la imagen de particion. No
obstante, puesto que se emplea un comando externo el cual tiene que leer y
escribir de forma sincrona en la imagen de la partición, esta paso es varios
ordenes de magnitud mas lento que si esta estuviera montada (de forma similar a
como ocurre con las [mtools](http://www.gnu.org/software/mtools) en los sistemas
de archivos de tipo [FAT](https://technet.microsoft.com/en-us/library/cc938438.aspx)).

#### root

El usuario *root* es el encargado de gestionar el arranque del sistema y los
servicios globales de este, y por tanto tambien es el único con permisos de
administrador. Actualmente, su única funcionalidad es inicializar un
pseudo-terminal donde el usuario de demo *nodeos* pueda acceder al sistema y
mantenerlo activo cuando este termine su sesión para permitir un nuevo acceso.

A diferencia de otros sistemas operativos, este usuario no es necesario para su
funcionamiento ya que su única tarea es inicializar elementos del sistema que
son comunes a todos los usuarios o que requieren acceder a la información
contenida en los directorios de cada uno de ellos, como es el caso de
[logon](../../8. apéndices/módulos/1. módulos propios/logon.html) para poder
leer las contraseñas y la configuración de sesion de cada uno de ellos. En caso
de que estos no existan o no sean necesarios, se puede eliminar el directorio de
*root* de la particion de usuarios y a partir de entonces no habria en el
sistema ningun proceso en ejecucion con permisos de administrador excepto el
proceso que se ejecute con `PID 1`
([century](../../8. apéndices/módulos/2. colaboraciones con proyectos externos/node-century.md)).

La administración de los servicios globales hace uso de una versión de
[forever](../../8. apéndices/módulos/2. colaboraciones con proyectos externos/forever.md)
a la que se le ha añadido soporte para que inicie al arrancar servicios
descritos en un archivo json y reiniciarlos cuando estos terminen para
mantenerlos activos. Actualmente solo se encargan de inicializar y mantener
corriendo un terminal virtual mediante el uso del módulo
[bin-getty](../../8. apéndices/módulos/2. colaboraciones con proyectos externos/node-bin-getty.md)
para solicitar el acceso al sistema mediante una instancia de
[logon](../../8. apéndices/módulos/1. módulos propios/logon.md), por lo que se
plantea el usar en su lugar un módulo mas simple hecho a proposito para esta
funcionalidad y que tenga menos dependencias.

#### nodeos

La funcionalidad del usuario *nodeos* es solamente servir de ejemplo de como
seria un usuario del sistema, aunque tambien incluye algunos comandos basicos y
utilidades de medición rendimiento para pruebas.

Entre los modulos que se instalan en este usuario de ejemplo estan:

* **basicos**: el gestor de paquetes `npm`, una version mejorada de la shell
  `nsh`, y `bin-man` para poder leer los archivos `README.md` de los modulos
  como se haria con las paginas de manual en un sistema UNIX.
* **red**: `ip` e `ifconfig` para configurar la tarjeta de red y las rutas de
  red, y `ntp-client` y `dhcpjs` para diversas pruebas
* **editores**: `slap`, y se piensa añadir tambien `hipster`
* **benchmarks**: `performance` y `loadtest`

Aparte, tambien se descargan e instalan desde sus repositorios los modulos
[blessed-contrib](https://github.com/yaronn/blessed-contrib) y
[node-canvas](../../../8. apéndices/2. módulos/3. node-canvas.html), con objeto
de ser usados para pruebas y demos de graficos ASCII y en framebuffer,
respectivamente.

Por ultimo, se copian en el directorio `/etc` dentro del propio directorio del
usuario los archivos `logon.json` que sera leido por *logon* para permitir el
acceso al sistema, y `resolv.conf` para que funcione correctamente la resolución
de nombres usando por defecto los servidores
[DNS de Google](https://developers.google.com/speed/public-dns), por lo que
al estar dentro de su directorio de usuario pueden ser cambiados por el mismo
afectando solamente a sus propias aplicaciones.
