### usersfs

La última capa del sistema corresponde a la generación de la partición de los
usuarios. No tiene una repercusion directa en el funcionamiento del sistema,
sino que su funcionalidad es principalmente para hospedar un usuario de ejemplo
y mostrar como se crearia una particion de usuarios real para un entorno de
producción. Por tal motivo solo contiene los usuarios *root* y *nodeos*, estando
pendiente de definir un metodo para generar dicha partición de usuarios de forma
independiente al resto del sistema.

El método para generar ambos usuarios es el mismo, consistente en la creación de
sus directorios de usuario y despues la instalacion de los paquetes definidos en
un archivo de texto usando `npm`. La instalación se hace globalmente para ambos
usuarios dentro de su propio directorio (por lo que despues mediante el uso del
sistema de archivos único por cada usuario tendran la impresión que estan
instalados globalmente para todo el sistema) y configurada de tal forma que use
el [cross-toolchain](1. cross-toolchain.html) antes generado, despues se copian
sus archivos de configuración como por ejemplo los programas a arrancar al
inicio del sistema o las credenciales de acceso, y por último el ejecutable que
debe actuar como *init* de dicho usuario.

Para generar la imagen de partición, se hace uso del comando
[genext2fs](http://genext2fs.sourceforge.net), indicando que se genere el
sistema de archivos `Ext2` con un tamaño de bloque de 1024 bytes y un ratio de
4KB por inodo (por defecto *genext2fs* genera el menor número de inodos
necesario para hospedar el sistema de archivos a crear, lo cual solo es útil
mayormente en sistemas de solo-lectura para reducir su tamaño), siendo estos los
valores usados por defecto en entornos de escritorio habitualmente y que ofrecen
una buena relaccion de espacio consumido para metadatos respecto a los propios
datos en condiciones normales. Despues se activa manualmente en dicho sistema de
archivos el soporte para journaling para mejorar la integridad de los datos
mediante la ejecución del comando `/sbin/tune2fs -j`.

Para aumentar la seguridad del sistema operativo, el sistema de archivos de los
usuarios se crea con la opcion *squash* la cual asigna a todos los archivos el
UID y GID `0` (generalmente asociados al usuario administrador) y sus permisos
de forma que solo puedan ser accedidos por el propietario de estos. Puesto que
el UID y GID del directorio de usuario son usados para identificar al usuario y
posteriormente definir los permisos de la jaula *chroot* donde se ejecutara este,
despues se utiliza un script que internamente hace uso de la utilidad
[debugfs](http://linux.die.net/man/8/debugfs) para poder cambiar el UID y GID de
los archivos correspondientes al usuario *nodeos* sin necesitar permisos de
administrador al poder hacerlo directamente sobre la imagen de partición. No
obstante, puesto que se emplea un comando externo el cual tiene que leer y
escribir de forma sincrona en la imagen de la partición, esta paso es varios
ordenes de magnitud mas lento que si ésta estuviera montada (de forma similar a
como ocurre con las [mtools](http://www.gnu.org/software/mtools) al trabajar con
sistemas de archivos de tipo VFAT), por lo que se plantea que en el futuro se
sistituya el uso de `debugfs` por un módulo que permita la manipulación de
sistemas de archivos en formato ext4.

#### root

El usuario *root* es el encargado de gestionar el arranque del sistema y los
servicios globales de este, y por tanto también es el único con permisos de
administrador. Actualmente, su única funcionalidad es inicializar un
pseudo-terminal donde el usuario de demo *nodeos* pueda acceder al sistema y
mantenerlo activo cuando este termine su sesión para permitir un nuevo acceso.

A diferencia de otros sistemas operativos, este usuario no es necesario para su
funcionamiento ya que su única tarea es inicializar elementos del sistema que
son comunes a todos los usuarios o que requieren acceder a la información
contenida en los directorios de cada uno de ellos, como es el caso de
[logon](../../8. apéndices/módulos/1. módulos propios/logon.html) para poder
leer las contraseñas y la configuración de sesión de cada uno de ellos. En caso
de que estos no existan o no sean necesarios, se puede eliminar el directorio de
*root* de la particion de usuarios y a partir de entonces no habria en el
sistema ningun proceso en ejecución con permisos elevados excepto (por razones
obvias al ser arrancado por el kernel) el proceso que se ejecute con `PID 1`
([century](../../8. apéndices/módulos/2. colaboraciones con proyectos externos/node-century.html)).

La administración de los servicios globales hace uso de una versión de
[forever](../../8. apéndices/módulos/2. colaboraciones con proyectos externos/forever.html)
a la que se le ha añadido soporte para que al arrancar el sistema inicie los
servicios descritos en un archivo json y reiniciarlos cuando estos terminen para
mantenerlos activos. Actualmente solo se encargan de inicializar y mantener
corriendo un terminal virtual mediante el uso del módulo
[bin-getty](../../8. apéndices/módulos/2. colaboraciones con proyectos externos/node-bin-getty.html)
para solicitar el acceso al sistema mediante una instancia de
[logon](../../8. apéndices/módulos/1. módulos propios/logon.html), por lo que se
plantea el usar en su lugar un módulo mas simple hecho a proposito para esta
funcionalidad y que requiera de menos dependencias para poder reducir su tamaño.

#### nodeos

La funcionalidad del usuario *nodeos* es solamente servir de ejemplo de como
seria un usuario normal del sistema, aunque tambien incluye algunos comandos
básicos y utilidades de medición de rendimiento para pruebas.

Entre los módulos que se instalan en este usuario de ejemplo estan:

* **basicos**: el gestor de paquetes `npm`, una versión mejorada de la shell
  [nsh](https://github.com/groundwater/node-bin-nsh), y
  [bin-man](https://github.com/groundwater/node-bin-man) para poder leer los
  archivos `README.md` de los modulos como se haria con las paginas de manual en
  un sistema UNIX tradicional.
* **red**: [ip](https://github.com/NodeOS/ip) e
  [ifconfig](https://github.com/NodeOS/ifconfig) para configurar la tarjeta de
  red y las rutas de red, y [dhcpjs](https://github.com/apaprocki/node-dhcpjs) y
  [ntp-client](https://github.com/moonpyk/node-ntp-client) para diversas pruebas.
* **editores**: [slap](https://github.com/slap-editor/slap), aunque tambien se
  esta planteando añadir [hipster](https://github.com/dominictarr/hipster) como
  alternativa.
* **benchmarks**: [performance](https://github.com/alexfernandez/performance) y
  [loadtest](https://github.com/alexfernandez/loadtest).

Aparte, también se descargan e instalan desde sus repositorios los modulos
[blessed-contrib](https://github.com/yaronn/blessed-contrib) y
[node-canvas](../../8. apéndices/2. módulos/3. node-canvas.html), con objeto de
ser usados para pruebas y demos de gráficos ASCII y en framebuffer,
respectivamente.

Por último, se copia en el directorio `/etc` dentro del propio directorio del
usuario el archivos `logon.json` que sera leido por *logon* para permitir el
acceso al sistema. Anteriormente tambien se incluia un archivo `resolv.conf` con
los servidores [DNS de Google](https://developers.google.com/speed/public-dns)
para que funcionara correctamente la resolución de nombres, aunque lo solución
adoptada ha sido que estos sean inicializados en el arranque por el propio
kernel de Linux por DHCP mediante el uso del argumento `ip=`. No obstante,
gracias al uso de *OverlayFS* pueden seguir siendo cambiados por el usuario por
otros que el decida afectando solamente a sus propias aplicaciones.
