## Diseño

### División en capas

![Organización de las distintas capas de las que se compone NodeOS. Las capas superiores se apoyan o sustituyen la funcionalidad proporcionada por las capas inferiores](img/NodeOS layer 4.png)

El sistema esta organizado en capas, correspondiente cada una de ellas a un
módulo npm independiente siguiendo la filosofia de diseño modular que promueve
la comunidad de Node.js, y su división sigue el diseño de la organización
original del proyecto basada en la arquitectura de contenedores de Docker, a la
cual he revisado el ambito correspondiente a cada una. Dichas capas son:

* [barebones](3. Implementación/2. barebones.html), encargada de un arranque
  mínimo del sistema, mostrando directamente el interprete REPL de Node.js.
* [initramfs](3. Implementación/3. initramfs.html), monta la partición con los
  directorios de los usuarios y ejecuta una preparación previa del sistema.
* [rootfs](3. Implementación/4. rootfs.html), genera una partición de arranque
  de solo-lectura con el contenido de las dos capas anteriores segun para que
  plataforma se este generando, de forma que despues pueda grabarse en un disco
  o pendrive que puedan ser usados para arrancar el sistema de forma autonoma en
  hardware real como PCs o el micro-ordenador Raspberry Pi.
* [usersfs](3. Implementación/5. usersfs.html), ejemplo de partición con los
  directorios de los usuarios, incluido un ususario administrador *root*.

Cada capa es autonoma en si misma pudiendo ejecutarse independientemente y se
apoya en las anteriores para ofrecer su funcionalidad. Por ejemplo, usando la
capa *barebones* de forma aislada arranca el sistema y ofrece acceso a un
interprete REPL de Node.js, similar al ofrecido por algunos microcomputadores de
los años 80 como ZX Spectrum, aunque usandose en este caso Javascript en vez de
BASIC como lenguaje.

### Módulos

Los módulos correspondientes a cada capa estan integrados dentro del código del
proyecto principal aunque estan diseñados como módulos independientes. Ésto es
asi por dos razones:

1. la normativa del Concurso de Software Libre indica explicitamente que
   "[solo se podra participar en un proyecto a la vez](http://www.concursosoftwarelibre.org/1415/bases)",
   lo que implica indirectamente que sólo puede usarse un único repositorio.
   Debido a la filosofia modular de Node.js en condiciones normales se usaria un
   repositorio distinto para cada una de las capas provocando que posteriormente
   se evaluase un repositorio "vacio" al estar toda la funcionalidad en otros
   proyectos externos, por lo que decidí organizarlas como
   [bundledDependencies](https://docs.npmjs.com/files/package.json#bundleddependencies)
   hasta la finalizacion de dicho concurso.
2. npm en su estado actual tiene varias limitaciones que imposibilitan el poder
   instalar los módulos correspondientes a las distintas capas de forma
   independiente, como es la instalación de las dependencias sin un orden bien
   definido, diversos bugs en los que se instalan paquetes sin haberse instalado
   primero correctamente sus dependencias, o la mas importante la instalación de
   dependencias en arbol, lo que provocaria que se generara el cross-compiler
   varias veces desperdiciando mucho tiempo en su generación al no usarse una
   única copia.

No obstante, la intención a lar go plazo es que las distintas capas del sistema
estén en distintos proyectos y que los problemas relativos a npm estén resueltos
cuando se adapte el sistema a npm 3, al incorporar la instalación multi-etapa y
usa una jerarquia de dependencias maximamente plana. Tambien se plantea dividir
dichos módulos en otros mas enfocados, como son el binario de Node.js o el
kernel de Linux o incluso la posibilidad de que los módulos instalados por los
usuarios dentro de su directorio puedan tambien ser considerados dependencias de
cara a una posterior instalacion de estos en el mismo o en otro sistema.

Aparte de los módulos correspondientes a cada una de las capas del sistema,
tambien se ha hecho un módulo especifico para la generación del cross-compiler,
de forma que éste también este integrado dentro del ciclo de vida de npm y la
compilacién de los distintos médulos sea independiente del sistema subyacente, y
también se ha hecho que el propio sistema este definido como un paquete npm,
aunque al delegar toda su funcionalidad a los módulos de cada una de las capas
del sistema o a módulos externos su funcionalidad es mínima y se reduce a
recolectar los productos generados por las distintas capas para permitir su
ejecución con QEmu, y segun la plataforma para la que se este generando crear
una imagen de disco o un archivo zip para su publicación. Este módulo esta
definido como [privado](https://docs.npmjs.com/files/package.json#private) para
evitar su publicación en el registro npm al no tener librerias o componentes
directamente consumibles por otros módulos, ya que la forma de uso esperada es
que se descargue su código fuente desde el repositorio de GitHub y se genere a
partir de él, y que las versiones personalizadas o derivabas de NodeOS
("[sabores](../../6. conclusiones/2. Posibles trabajos futuros.html#"Sabores")")
se creen mediante forks de este proyecto principal. Ésto esta facilitado
precisamente por la filosofia modular de Node.js, ya que permite que este módulo
principal sea mínimo y las personalizaciones se reduzcan a definir sus
dependencias en otros paquetes alternativos, lo cual ademas facilita que haya
una gran cantidad de paquetes comunes en todos ellos haciendo todas las
versiones derivadas uniformes y compatibles entre si.

### Sistema de archivos por usuario

La capacidad de poder ofrecer un sistema de archivos raiz único e independiente
por cada usuario es posible gracias al uso combinado de OverlayFS y chroot.
[OverlayFS](https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt)
es un sistema de archivos que permite apilar varios sistemas de archivos en un
único punto de montaje al estilo de [UnionFS](http://unionfs.filesystems.org) en
[FreeBSD](https://www.freebsd.org) o [bind](http://man.cat-v.org/plan_9/2/bind)
en [Plan 9](http://plan9.bell-labs.com/plan9), e introducido dentro del
repositorio principal del kernel de Linux en la versión `3.18-rc2`, el cual se
mejoró posteriormente en la versión `3.20-rc1` (despues renombrada a `4.0-rc1`
cuando se decidio no usar en el desarrollo del kernel números de versión menor
[excesivamente grandes](https://plus.google.com/+LinusTorvalds/posts/jmtzzLiiejc))
añadiendo soporte para usar varias capas en solo-lectura en el mismo punto de
montaje.

La estructura empleada consiste en usar el sistema de archivos raiz ubicado
dentro del initram como sistema base de solo-lectura, montando encima el
directorio de cada usuario y despues creando una jaula chroot dentro de el. De
esta forma, los usuarios quedan contenidos dentro de su propio directorio de
usuario y aislados del sistema y entre si, lo que permite por ejemplo que el
usuario modifique o sobreescriba los elementos comunes contenidos dentro del
initram como son el binario de Node.js y las librerias dinamicas del sistema, ya
que todos esos cambios quedaran reflejados únicamente en su propio sistema de
archivos raiz alojado dentro de su directorio de usuario. Ademas como medida
adicional de seguridad se ha establecido el *umask* de los archivos por defecto
a 0077 (*rwx------*) para permitir sólamente al propietario de los archivos
acceder a estos.

Mediante esta técnica, se genera una jerarquia de archivos uniforme donde a
efectos prácticos el directorio del usuario es la raiz del sistema. Esto se
manifiesta por ejemplo cuando el usuario instala paquetes npm globalmente, para
lo cual no requiere permisos de administrador a diferencia de en sistemas
normales. Esto mismo tambien podria conseguirse mediante el uso de la variable
de entorno `npm_config_prefix`, pero en este caso puede funcionar con la
configuración por defecto sin afectar a los demas usuarios.

El uso de OverlayFS y de un sistema de archivos propio por cada usuario tiene
otra ventaja, y es que seria muy facil que los usuarios definieran en su script
de inicio el que se montara una unidad de almacenamiento en linea como Dropbox,
Google Drive o Amazon S3 como directorio de usuario combinandolo con algun
mecanismo de cache en local, haciendo que todos sus archivos estuvieran de forma
transparente accesibles en cualquier momento desde Internet.
