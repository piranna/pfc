## Posibles trabajos futuros

El proyecto esta en proceso de liberar proximamente una version *alpha* publica.
Su desarrollo hasta el momento se ha centrado principalmente en definir la
arquitectura del sistema y como se espera que se comporte de cara al usuario y a
las aplicaciónes, para a partir de este punto continuar su desarrollo sobre una
base solida sin tener necesidad de hacer grandes cambios en el futuro sobre el
trabajo ya realizado. Sin embargo, ya se han empezado a considerar posibles vias
de actuacion a desarrollar para una futura version *beta*.

### Compilacion para ARM y MIPS

Actualmente el cross-compiler da problemas al intentar compilar el kernel para
una plataforma distinta a x86, aunque en principio es posible hacerlo. Una
posible solucion seria utilizar un generador de toolchains como
[crosstool-NG](http://crosstool-ng.org/), aunque en un principio se descarto
esta idea para poder tener mayor control sobre el proceso de generacion,
importante puesto que se pretende en el futuro sustituir
[GCC](https://gcc.gnu.org/) como compilador del sistema por
[LLVM](http://llvm.org/) al haber
[implementaciones en Javascript](https://github.com/kripken/llvm.js) que
facilitarian el hacer el sistema auto-contenido, y tambien para eliminar
dependencias externas que pudieran complicar dicho proceso. Es por esto que se
pretende mejorar el soporte del cross-compiler para estas plataformas integrando
las instrucciones proporcionadas por otros proyectos mas especificos como
[PiLFS](http://www.intestinate.com/pilfs/).

### Kernels alternativos

Puesto que todo el espacio de usuario esta basado en Node.js el cual esta
soportado en varios sistemas operativos, seria relativamente facil el portar el
sistema para que pueda funcionar con un kernel alternativo a Linux, de forma
similar a como ocurre con el sistema operativo Debian el cual tiene versiones
basadas en kFreeBSD o HURD. Entre las distintas opciones evaluadas la mejor
candidata para una primera adaptacion es NetBSD, ya que al estar orientado para
sistemas embebidos su sistema de construcción ```build.js``` esta diseñado para
la portabilidad y la compilacion cruzada incluso entre distintos sistemas
operativos (con lo que se podria generar desde un host Linux), aunque a largo
plazo se espera poder hacer que NodeOS se ejecute sobre runtime.js, ya que al
estar el kernel escrito tambien en Javascript se facilitaria la integración con
este y aumentar el rendimiento y la seguridad del sistema.

### "Sabores"

El sistema actualmente se ofrece como una unica base que incluye soporte para
framebuffer, tarjetas de sonido... elementos que no son generalmente necesarios
en un servidor y que consumen recursos innecesariamente, precisamente una de las
razones de su creacion. Por esto se pretende ofrecer dos alternativas, una
optimizada para servidores en la nube y entornos embebidos (*mainframe*) a la
que se han eliminado todos los elementos superfluos (consolas virtuales, drivers
de tarjetas graficas...) y orientada principalmente para conectarse remotamente,
y otra mas indicada para un uso directo e interactivo (*workstation*) que
incluya dichos elementos y que pueda ofrecer una experiencia mas proxima a la de
un equipo de escritorio, lo cual convertiria al sistema en un entorno optimo
para el desarrollo de apliaciones para Node.js directamente sobre el.

### Mejorar la experiencia de usuario

Actualmente la unica forma de interactuar con el sistema es utilizando la shell
[nsh](https://github.com/piranna/nsh), la cual es bastante primitiva en cuanto a
su funcionalidad y no es valida para su uso diario. Por esto mismo se pretende
en el "sabor" *workstation* mejorar el uso en modo texto añadiendo un interprete
REPL que permita la ejecución directa de codigo, y tambien soporte para graficos
que permitan desarrollar un entorno de escritorio.

#### Modo texto

Se pretende mejorar el uso en modo texto sustituyendo la shell nsh actual por
el interprete REPL de Node.js usando
[coreutils.js](https://github.com/piranna/coreutils.js) para añadir los comandos
basicos a modo de funciones. Esto tendria la ventaja añadida de que al
ejecutarse todos los comandos dentro del propio interprete de Node.js, no solo
se mejoraria el rendimiento al no haber cambios de contexto en su ejecucion sino
tambien de poder desarrollar los scripts basandolos en streams de objetos, de
forma que permitiria una mayor integración con Node.js y mas versatilidad en su
uso.

Tambien se ha planteado la posibilidad de sustituirse mas adelante por
[janeway](https://github.com/skerit/janeway) como shell del sistema, al ofrecer
una funcionalidad similar a la de las consolas para desarrolladores de los
navegadores web Firefox y Chrome. Sin embargo esto ultimo necesitaria un mejor
soporte de [blessed](https://github.com/chjj/blessed) y del uso de interfaces en
modo texto, lo cual incluye la necesidad del uso de una fuente optimizada para
[terminales con 512 glifos y soporte de patrones Braille](https://github.com/NodeOS/nodeos-console-font)
y la modificacion del kernel de Linux para que pueda usarlas por defecto, ya que
aunque tiene soporte para dichas fuentes actualmente solo esta habilitado para
que pueden ser definidas por el usuario o no pueden ser usadas durante el
arranque, complicando su uso en un entorno como el de NodeOS.

#### Interfaz grafica

Ademas de mejorar el uso de NodeOS en modo texto, se pretende añadir tambien la
posibilidad de usar una interfaz grafica. Para ello la primera aproximación es
usar el modulo [node-canvas](https://github.com/Automattic/node-canvas), el cual
ha añadido soporte para el dispositivo de framebuffer de Linux (*fbdev*)
[especificamente para poder usarse en NodeOS](https://github.com/Automattic/node-canvas/issues/533).

Sin embargo, a largo plazo se pretende desarrollar una interfaz grafica basada
en un motor de renderizado HTML como son [WebKit]() o [Gecko]() (en concreto
[Chrome Embedding Framework]() y [Servo]()), haciendo que
funcionen directamente sobre el EGL de forma similar a como funciona el sistema
grafico de ChromeOS, lo cual permitiria aceleración grafica por hardware. Sin
embargo, se han encontrado diversos problemas principalmente debido a la falta
de documentacion sobre como usar EGL bajo Linux, ya que la mayoria de la
documentación y ejemplos disponibles requieren del uso del entorno grafico X11
de forma directa o indirecta. La principal razon por la que se quiere usar EGL
en lugar de X11 es para hacer un uso menor de los recursos al no usar
componentes intermedios innecesarios (en linea a la filosofia general del
sistema), ya que es posible crear todos los componentes necesarios de un sistema
de ventanas y un entorno de escritorio usando solamente HTML y CSS, como ya han
demostrado algunos proyectos como [eyeOS]() y otros muchos gestores de ventanas
virtuales que pueden ejecutarse dentro del navegador.

Respecto a las aplicaciones graficas basadas en una interfaz HTML, se pretende
que en el desarrollo de estas mantengan una arquitectura cliente-servidor donde
la interfaz este aislada de su functionalidad interna y no se permita acceder
directamente a las librerias de Node.js como si permiten otros entornos como
[NW.js](http://nwjs.io/) o [electron](http://electron.atom.io/). Este diseño
provoca que el motor HTML actue simplemente como un visor sin funcionalidad
extra respecto a la de un navegador web normal, facilitando su mantenimiento y
portabilidad, pero tambien garantizando la compatibilidad de las aplicaciones
web actuales en NodeOS, y tambien que las aplicaciones desarrolladas
especificamente para NodeOS puedan usarse remotamente desde cualquier navegador
web.

### Reducir consumo de memoria

Al estar el sistema basado en initram y requerir todos los procesos una
instancia de Node.js es importante estudiar alternativas para reducir el consumo
de memoria. Entre ellas estan:

* reducir el tamaño del binario de Node.js reduciendo su dependencia de la
  libreria libc del sistema, al estar permanentemente en memoria
* estudiar el uso de XIP para evitar que se copie el codigo del ejecutable a la
  memoria RAM, al estar este ya cargado dentro del initram
* usar el modulo [kexec]() dentro de ```/usr/bin/env``` para ejecutar binarios
  en lugar [child_process](), de forma similar a como se esta haciendo para
  reusar la instancia de Node.js al ejecutar scripts en Javascript
* potenciar el uso de [fork]() y los isolates de v8 como plantea [runtime.js]()
  en lugar de crear instancias completas de Node.js
* modificar Node.js para que reuse las instancias existentes de Node.js
  (utilizando un pidfile o similar) en vez de crear otras nuevas
