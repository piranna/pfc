## Posibles trabajos futuros

El proyecto esta en proceso de liberar proximamente una version *alpha* publica.
Su desarrollo hasta el momento se ha centrado principalmente en definir la
arquitectura del sistema y como se espera que se comporte de cara al usuario y a
las aplicaciónes, para a partir de este punto continuar su desarrollo sobre una
base solida sin tener necesidad de hacer grandes cambios en el futuro sobre el
trabajo ya realizado. Sin embargo, ya se han empezado a considerar posibles vias
de actuacion a desarrollar para una futura version *beta*.

### Compilacion para ARM y MIPS

Actualmente el cross-compiler da problemas al intentar compilar el kernel para
una plataforma distinta a x86. Una posible solucion seria utilizar un generador
de toolchains como [crosstool-NG](http://crosstool-ng.org), aunque en un
principio se descarto esta idea para poder tener mayor control sobre el proceso
de generacion, importante puesto que se pretende en el futuro sustituir
[GCC](https://gcc.gnu.org) como compilador del sistema por
[LLVM](http://llvm.org) al haber
[implementaciones en Javascript](https://github.com/kripken/llvm.js) que
facilitarian el hacer el sistema auto-contenido, y tambien para eliminar
dependencias externas que pudieran complicar dicho proceso. Es por esto que se
pretende mejorar el soporte del cross-compiler para estas plataformas integrando
las instrucciones proporcionadas por otros proyectos mas especificos como
[PiLFS](http://www.intestinate.com/pilfs), version de Linux From Scratch
especifica para Raspberry Pi.

### Kernels alternativos

Puesto que todo el espacio de usuario esta basado en Node.js el cual esta
soportado en varios sistemas operativos, seria relativamente facil el portar el
sistema para que pueda funcionar con un kernel alternativo a Linux, de forma
similar a como ocurre con el sistema operativo Debian el cual tiene versiones
basadas en kFreeBSD o HURD. Entre las distintas opciones evaluadas la mejor
candidata para una primera adaptacion es NetBSD, ya que al estar orientado para
sistemas embebidos su sistema de construcción `build.js` esta diseñado para la
portabilidad y la compilacion cruzada incluso entre distintos sistemas
operativos (con lo que se podria generar desde un host Linux), aunque a largo
plazo se espera poder hacer que NodeOS se ejecute sobre runtime.js, ya que al
estar el kernel escrito tambien en Javascript seria facil la integración con
este y se podrian aprovechar sus diseño para aumentar el rendimiento y la
seguridad del sistema.

### "Sabores"

El sistema actualmente se ofrece como una unica base que incluye soporte para
distintos elementos multimedia como son el framebuffer, tarjetas de sonido...
que no son generalmente necesarios en un servidor y que consumen memoria y
recursos innecesariamente, siendo esta precisamente una de las razones de la
creacion de NodeOS. Debido a esto se pretende ofrecer dos alternativas, una
optimizada para servidores en la nube y entornos embebidos (*mainframe*) a la
que se han eliminado todos los elementos superfluos (consolas virtuales, drivers
de tarjetas graficas...) y orientada principalmente para conectarse remotamente,
y otra mas indicada para un uso directo e interactivo (*workstation*) que
incluya dichos elementos y que pueda ofrecer una experiencia mas proxima a la de
un equipo de escritorio, lo cual convertiria al sistema en un entorno optimo
para el desarrollo de apliaciones para Node.js directamente sobre el.

### Mejorar la experiencia de usuario

Actualmente la unica forma de interactuar con el sistema es utilizando la shell
[nsh](https://github.com/piranna/nsh), la cual es bastante primitiva en cuanto a
su funcionalidad y no es valida para su uso diario. Por esto mismo se pretende
en el "sabor" *workstation* mejorar el uso en modo texto añadiendo un interprete
REPL que permita la ejecución directa de codigo, y tambien soporte para graficos
que permitan desarrollar un entorno de escritorio.

#### Modo texto

Se pretende mejorar el uso en modo texto sustituyendo la shell nsh actual por
el interprete REPL de Node.js usando como base el modulo
[coreutils.js](https://github.com/piranna/coreutils.js) para añadir los comandos
basicos a modo de funciones. Esto tendria la ventaja añadida de que al
ejecutarse todos los comandos dentro del propio interprete de Node.js, no solo
se mejoraria el rendimiento al no haber cambios de contexto en su ejecucion sino
tambien de poder desarrollar los scripts basandolos en streams de objetos, de
forma que permitiria una mayor integración con Node.js y mas versatilidad en su
uso.

Tambien se ha planteado la posibilidad de sustituirse mas adelante por
[janeway](https://github.com/skerit/janeway) como shell del sistema, al ofrecer
una funcionalidad similar a la de las consolas para desarrolladores de los
navegadores web Firefox y Chrome. Sin embargo esto ultimo necesitaria un mejor
soporte de [blessed](https://github.com/chjj/blessed) y del uso de interfaces en
modo texto, lo cual incluye la necesidad del uso de una fuente optimizada para
terminales con 512 glifos y soporte de patrones Braille como por ejemplo
[nodeos-console-font](https://github.com/NodeOS/nodeos-console-font) y la
modificación del kernel de Linux para que pueda usarlas por defecto, ya que
aunque tiene soporte para dichas fuentes actualmente solo esta habilitado para
que pueden ser definidas por el usuario y no pueden ser usadas durante el
arranque, complicando su uso en un entorno como el de NodeOS.

#### Interfaz grafica

Ademas de mejorar el uso de NodeOS en modo texto, se pretende añadir tambien la
posibilidad de usar una interfaz grafica. Para ello la primera aproximación ha
sido portar a NodeOS el modulo
[node-canvas](../../8. apéndices/2. módulos/3. node-canvas.html) para poder
pintar graficos en el dispositivo de framebuffer de Linux (*fbdev*) usando la
API Canvas de HTML.

Sin embargo, a largo plazo se pretende desarrollar una interfaz grafica basada
en un motor de renderizado HTML como son [WebKit](http://www.webkit.org) o
[Gecko](https://developer.mozilla.org/es/docs/Gecko) (en concreto
[Chrome Content API](http://www.chromium.org/developers/content-module/content-api)
y [Servo](https://github.com/servo/servo)), haciendo que funcionen directamente
sobre el EGL de forma similar a como funciona el sistema grafico de ChromeOS, lo
cual permitiria aceleración grafica por hardware. Sin embargo, se han encontrado
diversos problemas principalmente debido a la falta de documentacion sobre como
usar EGL bajo Linux, ya que la mayoria de la documentación y ejemplos
disponibles requieren del uso del entorno grafico X11 de forma directa o
indirecta. La principal razon por la que se quiere usar EGL en lugar de X11 es
para hacer un uso menor de los recursos al no usar componentes intermedios
innecesarios (en linea a la filosofia general del sistema), ya que es posible
crear todos los componentes necesarios de un sistema de ventanas y un entorno de
escritorio usando solamente HTML y CSS, como ya han demostrado algunos proyectos
como [eyeOS](http://www.eyeos.com/es) y otros muchos gestores de ventanas
virtuales que pueden ejecutarse dentro del navegador.

Respecto a las aplicaciones gráficas basadas en una interfaz HTML, se pretende
que en el desarrollo de estas mantengan una arquitectura cliente-servidor donde
la interfaz este aislada de su functionalidad interna y no se permita acceder
directamente a las librerias de Node.js como si permiten otros entornos como
[NW.js](http://nwjs.io) o [electron](http://electron.atom.io). Este diseño
provoca que el motor HTML actue simplemente como un visor sin funcionalidad
extra respecto a la de un navegador web normal, facilitando su mantenimiento y
portabilidad, pero tambien garantizando la compatibilidad de las aplicaciones
web actuales en NodeOS, y tambien que las aplicaciones desarrolladas
especificamente para NodeOS puedan usarse remotamente desde cualquier navegador
web.

### Reducir el consumo de memoria

Al estar el sistema basado en initram y requerir todos los procesos una
instancia de Node.js es importante estudiar alternativas para reducir el consumo
de memoria. Entre ellas estan:

* reducir el tamaño del binario de Node.js reduciendo su dependencia de la
  libreria libc del sistema, al estar permanentemente en memoria
* estudiar el uso de XIP para evitar que se copie el codigo del ejecutable a la
  memoria RAM, al estar este ya cargado dentro del initram
* usar el modulo [kexec](https://github.com/jprichardson/node-kexec) dentro de
  `/usr/bin/env` para ejecutar binarios en lugar de
  [child_process](https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options),
  de forma similar a como esta haciendo para reusar la instancia de Node.js al
  ejecutar scripts escritos en Javascript.
* hacer uso de [workers](https://github.com/nodejs/node/pull/1159) y
  [multi-context](https://strongloop.com/strongblog/whats-new-node-js-v0-12-multiple-context-execution)
  para reusar automaticamente un mismo proceso de Node.js para ejecutar varios
  scripts de Javascript (tanto en Node.js como en NodeOS).
