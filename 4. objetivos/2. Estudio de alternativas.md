## Estudio de alternativas

A pesar de introducir algunas ideas novedosas como son el uso de un sistema de
archivos raiz único e independiente para cada usuario, el concepto de NodeOS de
utilizar un lenguaje de alto nivel para acceder directamente al hardware y crear
un sistema operativo a partir de él para facilitar su diseño y desarrollo y
reducir el consumo de recursos en las aplicaciones finales no es nuevo. Ya ha
habido varios casos en el pasado y hay varias alternativas actualmente (incluso
basadas en Javascript o Node.js), desde sistemas operativos tradicionales
minimalistas hasta interpretes implementados en hardware dentro de un microchip.

### Node.js en sistemas operativos tradicionales

Node.js puede ejecutarse nativamente en varios sistemas operativos (Linux, OSX,
FreeBSD, AIX, Windows...), con lo que en ese sentido bastaria con usar una
imagen mínima de dichos sistemas operativos (como por ejemplo Ubuntu Core o
CoreOS, este ultimo diseñado especificamente para ser ejecutado en servidores en
la nube dentro de instancias Docker) y añadirle la máquina virtual de Node.js
para tener un entorno similar al ofrecido por NodeOS. Este enfoque es el que
propone el sistema operativo [Linino](http://www.linino.org), el cual está
basado en [OpenWRT](https://openwrt.org) y que está principalmente orientado
para su uso junto con microcontroladores en robótica y en el Internet de las
Cosas.

Sin embargo, este enfoque de usar un sistema operativo ya existente (aunque sea
una versión reducida) en lugar de ejecutar Node.js directamente sobre el kernel
de Linux presenta dos desventajas:

1. se esta haciendo uso de componentes que suelen venir activados por defecto y
   que no son siempre necesarios, como es un demonio del sistema o un servidor
   ssh, que aunque en un sistema generico pueden ser utiles, estan consumiendo
   recursos que de otra manera podrian ser aprovechados. Esto en parte esta
   relacionado con el hecho de que al ser sistemas con un proposito generico se
   adhieren al estandar POSIX para poder ofrecer unos minimos de compatibilidad,
   lo cual require incluir muchos elementos que no son imprescindibles para
   ejecutar el binario de Node.js o cualquier otro interprete de alto nivel.
2. dichos componentes suelen distribuirse como binarios compilados o como
   scripts en bash o perl (y ocasionalmente en Python), aportando oscuridad al
   sistema y haciendolo mas dificil de entender, aprender y/o administrar. Esto
   no sucede en NodeOS, al ser solamente el kernel de Linux y el binario de
   Node.js los únicos componentes compilados y "oscuros" del sistema, al estar
   todos los componentes del espacio de usuario escritos en un lenguaje de alto
   nivel facilmente entendible como es Javascript, o C++ en el caso de los
   módulos compilados cuando es necesario acceder a los recursos del sistema a
   bajo nivel como son las llamadas al sistema[^1].

No obstante, aunque NodeOS ejecute el binario de Node.js directamente sobre el
kernel de Linux, precisamente al estar basado en una máquina virtual lo hace
agnostico del sistema sobre el que esta corriendo realmente, lo que permite que
cualquier módulo y aplicación que sea hecho para NodeOS tambien sea compatible
con Node.js ejecutandose en cualquiera otro sistema operativo y viceversa, con
la única posible excepcion de los modulos que hagan uso de las llamadas al
sistema del kernel de Linux, lo cual en tal caso solo requeririan de rehalizar
adaptaciones menores y muy localizadas y en cualquier caso podrian seguir
siendo compatibles con cualquier otro sistema o distribución basada en Linux.

La arquitectura organizada por capas de NodeOS ademas permite que pueda
adaptarse facilmente su estructura a una maquina virtual de cualquier otro
lenguaje o para sistemas dedicados donde solo sea necesario ejecutar una única
aplicacion. Esta es una arquitectura similar a la empleada en el proyecto
[node9](https://github.com/jvburnes/node9), aunque en tal caso se emplean
[Inferno](http://www.vitanuova.com/inferno) y [LuaJIT](http://luajit.org) como
kernel y maquina virtual respectivamente en vez de Linux y Node.js. Como
alternativa también estaria el uso de
[BareMetal OS](http://www.returninfinity.com/baremetal.html) como kernel ya que
esta enfocado a ser usado en sistemas donde solo se vaya a ejecutar una única
aplicación (en este caso, el binario de Node.js), pero al utilizar su propia API
para el desarrollo de aplicaciones se requeriria previamente portar Node.js o la
maquina virtual a usar a dicho sistema.

### Sistemas operativos basados en Javascript

Respecto a sistemas operativos cuyo espacio de usuario este *totalmente*
desarrollado en Javascript las alternativas existentes han sido pocas:

* [ES Operating System](https://code.google.com/p/es-operating-system), proyecto
  de investigación desarrollado por Nintendo desde 2006 y actualmente mantenido
  por [Esrille](http://www.esrille.com). Su arquitectura consiste en una pequeña
  capa en C++ con los drivers basicos (teclado y VGA) y sobre la que se ejecuta
  directamente un interprete Javascript y un motor de renderizado HTML (tambien
  hecho en Javascript), los cuales tienen acceso completo al sistema. Su mayor
  caracteristica es que todas sus APIs estan auto-generadas a partir de
  especificaciones en formato [WebIDL](http://heycam.github.io/webidl) lo que
  permite facilitar su documentación, pero su desarrollo parece estar parado.
* [AnarchyOS](https://github.com/juliangruber/anarchyos), iniciado por algunos
  de los mas importantes desarrolladores del ecosistema de Node.js y npm como
  [James Halliday](https://github.com/substack), su concepto era similar al de
  NodeOS en cuanto a usar Node.js como espacio de usuario pero su enfoque era
  mas "de arriba a abajo", siendo ideado como un sistema operativo administrado
  por npm (independientemente del lenguaje en que estuvieran hechos los
  ejecutables y librerias o si estos estan compilados), por lo que npm actuaria
  de gestor de dependencias al estilo de [apt](https://wiki.debian.org/es/Apt)
  en los sistemas [Debian](https://debian.org)/[Ubuntu](http://ubuntu.com) o
  [rpm](http://www.rpm.org)/[yum](http://yum.baseurl.org) en los sistemas
  basados en [RedHat](http://www.redhat.com/es)/[Fedora](https://getfedora.org))
  en vez de como un sistema operativo escrito en Javascript. El proyecto esta
  actualmente abandonado, aunque ahora algunos de sus desarrolladores como
  [Julian Gruber](https://github.com/juliangruber) son colaboradores de NodeOS.
* [Runtime.js](http://runtimejs.org), el cual es un caso especial porque no solo
  ofrece un espacio de usuario en Javascript, sino que el propio kernel esta
  hecho en torno al motor de Javascript [v8](https://code.google.com/p/v8), el
  mismo usado internamente por Node.js. Como caracteristica clave, su
  arquitectura enfocada a ejecutar únicamente aplicaciones basadas en Javascript
  permite aumentar el rendimiento usando un único contexto de ejecución e
  implementar el aislamiento entre "procesos" mediante el aprovechamiento de
  [isolates](http://stackoverflow.com/q/19383724) de v8 como elemento base (lo
  que se conoce como
  [sistema basado en lenguaje](http://en.wikipedia.org/wiki/Language-based_system)),
  lo que permite entre otras mejoras que el paso de mensajes entre procesos se
  reduzca a que el kernel solo necesite copiar un puntero. Algunos de los
  colaboradores de NodeOS tambien son desarrolladores de Runtime.js (entre ellos
  el creador original de NodeOS y anterior lider del proyecto,
  [Jacob Groundwater](https://github.com/groundwater)), y la idea a largo plazo
  es que pueda hacerse uso de Runtime.js como kernel de NodeOS para poder
  aprovecharse de sus ventajas.

El hecho de que haya habido pocos intentos de desarrollar un sistema operativo
en torno a Javascript puede deberse a la estigmatizatión a la que ha sido objeto
tradicionalmente de "lenguaje de juguete" solo valido para hacer pequeñas
animaciones en paginas web. Esta consideración solo empezo a cambiar en Abril de
2004 con el lanzamiento de [GMail](https://mail.google.com), siendo una de las
primeras paginas web en tener una funcionalidad equiparable a la de las
aplicaciones de escritorio, demostrando que el lenguaje podia ser usado para
proyectos complejos. Sin embargo, no es hasta la aparición de Node.js en Mayo de
2009 que no se empieza a considerar su uso fuera de los navegadores web (a
excepcion del motor Javascript
[Rhino](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino)), por
lo que probablemente sea este corto periodo de tiempo la principal razon de que
no se haya intentado anteriormente.

Debido a esto recientemente estan surgiendo algunos motores Javascript
orientados a su uso en sistemas embebidos, microcontroladores y el Internet de
las Cosas como son [JerryScript](http://www.jerryscript.net) desarrollado por
Samsung o [http://duktape.org](http://duktape.org), con los que seria factible
crear un entorno similar al ofrecido por *runtime.js* y que puedan sea usados
para ejecutar NodeOS en sistemas limitados en memoria aunque a costa de un
rendimiento menor, ya que para poder reducir su tamaño estos motores Javascript
suelen no incluir un compilador JIT que optimice su ejecución.

#### Sistemas operativos web

Como un caso particular de sistemas operativos hechos u orientados a Javascript
nos encontramos con los sistemas operativos web, los cuales ofrecen una
experiencia de uso similar a la de otros sistemas operativos de escritorio o
para dispositivos moviles, pero donde las aplicaciones estan hechas usando
tecnologias y estandares web como son el uso de Javascript, HTML y CSS. Se
pueden encontrar algunos primeros intentos en los años 90 con el desarrollo de
los *net client*, que pretendian delegar toda su funcionalidad en servidores en
Internet de forma similar en la que anteriormente los equipos *thin client* o
"terminales tontos" la delegaban en un ordenador central o *mainframe*.

El primer caso comercial de sistema operativo web fue
[WebOS](https://en.wikipedia.org/wiki/Web_operating_system), desarrollado por
[Palm](http://palm.com) en *2009* y el cual fracaso principalmente debido a que
las tecnologias web y el acceso a Internet no estaban lo suficientemente
desarrollados ni extendidos. Por otro lado, mas recientemente estan los casos de
[ChromeOS](https://es.wikipedia.org/wiki/Chrome_OS) (y sus derivados
[Hexxeh](http://chromeos.hexxeh.net) y [cloudReady](http://www.neverware.com)) y
[FirefoxOS](https://www.mozilla.org/es-ES/firefox/os/2.0), desarrollados por
Google y la fundacion Mozilla respectivamente. El planteamiento es el mismo en
ambos casos, ejecutar un navegador web directamente encima de un kernel Linux
([Chromium](https://www.chromium.org/Home) en el caso de ChromeOS, y
[Gecko](https://developer.mozilla.org/es/docs/Gecko) en el caso de FirefoxOS) y
a partir de él desarrollar todo el sistema mediante Javascript. En este sentido
NodeOS es comparable a ellos (usando Node.js en vez de un navegador web), con la
diferencia de que tanto ChromeOS como FirefoxOS estan enfocados a la ejecución
de aplicaciones web en ordenadores de escritorio y dispositivos moviles mientras
que NodeOS esta principalmente diseñado para su uso en servidores. No obstante,
hay bastante interes en disponer de un entorno gráfico en NodeOS y poder usarlo
como estación de trabajo ya que por las caracteristicas de este podria ser muy
similar a los servidores en producción, y de hecho ya tiene soporte para el
framebuffer de Linux y se espera que en el futuro se pueda ejecutar localmente
un motor de renderizado web como por ejemplo
[content shell](https://www.chromium.org/developers/content-module) basado en
Chromium o `Gecko`, por lo que NodeOS se convertiria en una alternativa a
ChromeOS y FirefoxOS como sistema operativo web. No obstante, en tal caso la
interfaz seria un mero añadido y no se proporcionarian APIs extra para el
desarrollo de aplicaciones gráficas como es el caso de ChromeOS y FirefoxOS
(aunque en este último caso el problema es menor al usar estandares W3C en vez
de APIs propias como sucede en el caso de ChromeOS), requiriendo que los
desarrolladores usen tecnologias y una arquitectura cliente-servidor web
tradicionales con objeto de aislar la interfaz gráfica del núcleo del programa y
aumentar la compatibilidad y la portabilidad, permitiendo el que puedan usarse
nativamente dichas aplicaciones de forma remota desde cualquier navegador web.

### Otros lenguajes y entornos de ejecución

En cuanto a otros lenguajes de alto nivel mas antiguos sí que ha habido otros
intentos previos, aunque generalmente han estado mas enfocados al desarrollo de
un kernel en dicho lenguaje en lugar de usar uno ya existente y construir el
espacio de usuario en dicho lenguaje encima de el, por lo que su diseño y
filosofia seria mas similar a la de *runtime.js*. Sin embargo dichos enfoques no
han tenido mucho exito en el pasado al ser realizados como hobbie o de forma
experimental sin un impulso economico detras.

#### Python

En el pasado han surgido varios proyectos que han intentado hacer un sistema
operativo en torno al lenguaje Python, no solo debido a su larga trayectoria
(fue creado en 1991) sino principalmente por su diseño de alto nivel y facilidad
de aprendizaje, que son sus dos principales bazas, siendo el intento mas antiguo
[Cleese](http://jtauber.com/cleese), cuyo desarrollo empezo en 2006 y el cual
permitia ejecutar directamente sobre el hardware el interprete Python estandar
[CPython](https://www.python.org) sin modificar al ser compilado usando una
implementacion de bajo nivel de la libreria estandar de C[^2]. Una idea similar
es la que ofrece [PyCorn](https://sites.google.com/site/pycorn), aunque en este
caso esta mas enfocado a plataformas ARM para crear sistemas similares a los
micro-ordenadores de los años 80. Sin embago, ambos proyectos parecen estar
abandonados.

Mas recientemente (Abril 2015) y tambien basado en el interprete CPython se ha
[añadido un interprete Python al gestor de arranque GRUB](http://biosbits.org),
el cual basandose en los protocolos proporcionados por EFI tiene acceso directo
al hardware, por lo que aunque esta orientado a facilitar el manejo de GRUB
mediante el uso de scripts, a efectos practicos proporcionando un entorno
comparable a *runtime.js*, por lo que podria construirse un sistema operativo
dedicado directamente sobre el como demostraron en su demo en la
[PyCon 2015](https://lwn.net/Articles/641244) al hacerse la presentación
directamente en este entorno gracias a su acceso a la tarjeta de video. Ademas
proximamente tambien se podran usar los protocolos EFI para tener acceso a la
tarjeta de red, por lo que seria posible construir un servidor web directamente
sobre el sistema.

En cuanto a implementaciones de Python diseñadas especificamente para ser
ejecutadas directamente sobre el hardware sin un sistema operativo o un kernel,
la mas antigua fue [PyMite](https://code.google.com/p/python-on-a-chip) con
soporte para distintos microcontroladores PIC y al que yo personalmente añadí
soporte para [x86 mediante Multiboot](https://code.google.com/r/piranna-p14p)
con la intención de desarrollar un kernel de sistema operativo sobre él, en un
estilo similar a como esta diseñado *runtime.js*.

Desde Diciembre de 2013 también esta disponible
[MicroPython](https://github.com/micropython/micropython), el cual ofrece
soporte completo de la sintaxis de Python 3.4. Fue diseñado originalmente para
la placa [pyboard](https://github.com/micropython/pyboard) y despues portado por
la comunidad a otras placas basadas en diferentes microcontroladores y
microprocesadores, e incluso fue adaptado para poder ser usado como interprete
Python alternativo a CPython en algunos sistemas operativos, aunque esta
principalmente enfocado para ser usado en robotica y sistemas embebidos. Es por
este motivo por el que en Junio de 2015 el proyecto recibio financiacion por
parte de la Agencia Espacial Europea para poder estudiar la posibilidad de
[ser usado en el espacio](http://forum.micropython.org/viewtopic.php?f=8&t=744).

De similar forma que con los [sistemas operativos web](#sistemas-operativos-web),
algunos consideran a Ubuntu y al entorno [Sugar](http://sugarlabs.org) del
proyecto [One Laptop Per Children](http://one.laptop.org) como *sistemas
operativos Python* debido al uso extenso que hacen del lenguaje tanto para sus
scripts de administración y el desarrollo de aplicaciones propias (por ejemplo,
[Ubuntu Software Center](https://wiki.ubuntu.com/SoftwareCenter) esta hecho
integramente en Python, incluido el desarrollo de nuevos widgets gráficos
exclusivos de la aplicación) o en el caso de *OLPC* por desarrollar bindings a
aplicaciones ya existentes (como es el caso del juego
[Micrópolis](http://www.donhopkins.com/home/micropolis), hecho a partir del
codigo fuente del [Sim City](https://en.wikipedia.org/wiki/SimCity#SimCity)
original liberado por su propio autor). Sin embargo no son sistemas orientados a
que las aplicaciones esten basadas en el lenguaje sino que son sistemas
operativos genericos y hacen uso de multiples componentes hechos en otros
lenguajes, por lo que no se puede considerar que sean sistemas operativos
basados u orientados a Python estrictamente hablando sino solamente que hacen un
gran uso de dicho lenguaje.

#### Java

En los años 90 Sun apostó fuerte por el lenguaje Java intentando que estuviera
disponible en todas partes, y entre sus iniciativas estaba
[JavaOS](https://en.wikipedia.org/wiki/JavaOS), un sistema operativo en el que
todas las aplicaciones y componentes estuviesen escritos en Java (incluidos los
drivers) ejecutandose sobre una implementacion de su maquina virtual JVM encima
del hardware. En este sentido es similar a *runtime.js*, sin embargo no tuvo
excesivo exito a pesar de la popularidad del lenguaje en el entorno empresarial
y actualmente se considera un sistema obsoleto, recomendando la propia Sun que
se use en su lugar la maquina virtual Java sobre otros sistemas operativos
estandar.

Actualmente se encuentran en desarrollo dos alternativas de software libre que
siguen la misma filosofia que JavaOS: [JX](http://www4.cs.fau.de/Projects/JX),
desarrollado por la universidad de Erlangen (Alemania), y
[JNode](http://www.jnode.org).

#### C# #

Ha habido algunos intentos de hacer un sistema operativo basado en el framework
[Common Language Runtime](http://es.wikipedia.org/wiki/Common_Language_Runtime)
diseñado por Microsoft para su plataforma .NET, los cuales podrian hacer uso de
su soporte multilenguaje a diferencia de los casos anteriores que crean un
entorno optimizado para maquinas virtuales centradas en un único lenguaje,
aunque no han tenido mucha repercusion mas alla del ámbito academico o como
prueba de concepto en parte quizas debido a posibles temores relaccionados con
el control que ejerce Microsoft sobre el framework y las patentes de software
que posee sobre el mismo.

Como software libre apenas se conocen 3 casos con mayor o menor exito:

* [SharpOS](https://en.wikipedia.org/wiki/SharpOS_(operating_system)), el cual
  ya no esta activo y sus desarrolladores han centrado sus esfuerzos en el
  proyecto [MOSA](https://github.com/mosa/MOSA-Project) para crear un compilador
  .NET de alto rendimiento enfocado en el desarrollo de sistemas operativos.
* [CosmOS](https://github.com/CosmosOS/Cosmos) centrado en el desarrollo de
  componentes modulares sobre el que los usuarios puedan despues construir un
  sistema operativo a su medida y actualmente en estado alpha solo de interes
  academico (con intención en el futuro de hacerlo listo para producción).
* [FlingOS](http://www.flingos.co.uk), enfocado también en el ámbito educativo.

El caso mas notable de sistema operativo basado en el CLR es
[Singularity OS](http://research.microsoft.com/en-us/projects/singularity),
desarrollado por Microsoft como proyecto de investigación desde 2003. Como
caracteristicas principales están el uso de "Procesos Aislados por Software" y
compartiendo un único entorno de ejecución (similar a la propuesta de runtime.js
mediante el uso de isolates) lo cual es factible gracias a que el CLR es una
maquina virtual genérica la cual puede ejecutar programas de cualquier lenguaje
incluso de bajo nivel como C/C++ siempre que se hayan compilado en modo seguro
(lo cual es un requisito obligatorio para poder ser ejecutadas en *Singularity*)
de forma que la máquina virtual pueda aplicar sus medidas de seguridad y control
(aunque algo similar tambien seria factible con algunas limitaciones usando
[Emscripten](http://emscripten.org) para compilar C/C++ a Javascript, de forma
que puedan ejecutarse dichas aplicaciones en la máquina virtual de Node.js) y
con un diseño masivamente paralelo, aprovechando todos los núcleos disponibles
en el procesador e incluso la propia tarjeta gráfica a modo de coprocesador para
hacer calculos numericos de forma transparente. Sin embargo el proyecto esta
abandonado, en parte por su estatus de prueba de concepto y enfoque academico,
pero también por la marcha de su principal diseador James Larus para ser el
[Decano de la Escuela Politecnica Federal de Lausanne (EPFL)](http://www.zdnet.com/article/the-father-of-microsofts-singularity-os-moves-on).

#### Phantom

Dentro de los sistemas operativos basados en maquinas virtuales un caso curioso
es [Phantom](http://dz.ru/en/solutions/phantom), el cual hace uso de una máquina
virtual propia y que bajo la filosofia de "todo son objetos" (en el mismo modo
que la filosofia "todo son archivos" de los sistemas UNIX tradicionales) destaca
en el hecho de alejarse de todas las convenciones en cuanto a ficheros, sockets,
dispositivos y demas elementos del sistema usando en su lugar un pool de objetos
persistentes que ocupa todo el espacio de direcciones disponible, simplificando
el diseño tanto del sistema operativo como de sus aplicaciones al estar
virtualmente todo alojado en memoria en forma de objetos. Sistemas operativos
como este pueden tener una gran repercusión con nuevas arquitecturas de
computadoras como la propuesta por [HP](http://www.hp.com) con su proyecto
[The Machine](http://www.hpl.hp.com/research/systems-research/themachine).

#### hardware

En cuanto al uso de lenguajes de alto nivel directamente sobre el hardware, el
caso mas extremo lo encontramos en el soporte del lenguaje directamente por la
CPU. Quizas el mas curioso sea el del lenguaje SPIN usado por los
microcontroladores Propeller y Propeller 2, el cual tiene una sintaxis parecida
a BASIC y cuyo interprete esta implementado dentro del propio microcontrolador.
Sin embargo, el mas notable fueron los
[procesadores Java](https://en.wikipedia.org/wiki/Java_processor), los cuales
fueron diseñado para que su conjunto de instrucciones correspondiese al bytecode
de la máquina virtual Java desarrollada por Sun resultando en una implementación
hardware del lenguaje. Se planteó usarse como coprocesador en las
[JavaStation](https://en.wikipedia.org/wiki/JavaStation) para acelerar la
ejecución de las aplicaciones de JavaOS, aunque dicha plataforma dejo de tener
uso antes de que llegaran a integrarse. No obstante, dicha idea puede resurgir
en el futuro gracias a [WebAssembly](https://en.wikipedia.org/wiki/WebAssembly),
el cual pretende crear un formato bytecode para ser usado en aplicaciones web y
Javascript, y que tambien podria implementarse en hardware al igual que sucedió
con los procesadores Java y del cual los sistemas operativos web y tambien muy
especialmente NodeOS o runtime.js podrian sacar ventaja aumentando drasticamente
su rendimiento.


[^1]: Con el futuro soporte de la Interfaz de Funciones Foraneas ofrecida por la libreria [libffi](https://sourceware.org/libffi) nativamente dentro del [core de Node.js](https://github.com/nodejs/io.js/pull/1865) como metodo de acceso estandar a las librerias del sistema este último punto no sera necesario tampoco.
[^2]: Hoy dia esto es relativamente trivial con algunas librerias estandar de C con soporte nativo para ser usadas directamente sobre el hardware sin un sistema operativo como [NewLib](https://sourceware.org/newlib) o [musl](http://www.musl-libc.org), pero por entonces no existia ninguna.
